---
phase: 31-context-expansion
plan: 03
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - src/cocosearch/mcp/server.py
  - tests/unit/mcp/test_server_context.py
autonomous: true

must_haves:
  truths:
    - "MCP clients can request context via context_before and context_after parameters"
    - "MCP uses same defaults as CLI (smart expansion on)"
    - "Context appears in MCP search_code response"
  artifacts:
    - path: "src/cocosearch/mcp/server.py"
      provides: "MCP search_code with context parameters"
      contains: "context_before.*context_after"
    - path: "tests/unit/mcp/test_server_context.py"
      provides: "Tests for MCP context parameters"
      min_lines: 60
  key_links:
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/search/context_expander.py"
      via: "ContextExpander for context retrieval"
      pattern: "context_expander"
---

<objective>
Add context expansion parameters to MCP search_code tool.

Purpose: Enable MCP clients (Claude, other LLMs) to request surrounding code context with search results.
Output: Updated MCP server with context_before, context_after, and smart_context parameters.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-context-expansion/31-CONTEXT.md
@.planning/phases/31-context-expansion/31-01-SUMMARY.md
@src/cocosearch/mcp/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add context parameters to MCP search_code</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
Update `src/cocosearch/mcp/server.py` to add context expansion to search_code:

1. **Add import:**
   ```python
   from cocosearch.search.context_expander import ContextExpander
   ```

2. **Update search_code function signature:**
   Add new parameters after symbol_name:
   ```python
   @mcp.tool()
   def search_code(
       query: Annotated[str, Field(description="Natural language search query")],
       index_name: Annotated[...] = None,
       limit: Annotated[int, ...] = 10,
       language: Annotated[str | None, ...] = None,
       use_hybrid_search: Annotated[bool | None, ...] = None,
       symbol_type: Annotated[str | list[str] | None, ...] = None,
       symbol_name: Annotated[str | None, ...] = None,
       context_before: Annotated[
           int | None,
           Field(
               description="Number of lines to show before each match. "
               "Overrides smart context expansion when specified."
           ),
       ] = None,
       context_after: Annotated[
           int | None,
           Field(
               description="Number of lines to show after each match. "
               "Overrides smart context expansion when specified."
           ),
       ] = None,
       smart_context: Annotated[
           bool,
           Field(
               description="Expand context to enclosing function/class boundaries. "
               "Enabled by default. Set to False for exact line counts only."
           ),
       ] = True,
   ) -> list[dict]:
   ```

3. **Update result processing:**
   After getting search results, apply context expansion:
   ```python
   # Create context expander for file caching
   expander = ContextExpander()

   # Convert results to dicts with line numbers, content, and context
   output = []
   for r in results:
       start_line = byte_to_line(r.filename, r.start_byte)
       end_line = byte_to_line(r.filename, r.end_byte)

       # Get context if requested or smart context enabled
       context_before_text = ""
       context_after_text = ""

       if context_before is not None or context_after is not None or smart_context:
           # Determine language for smart expansion
           ext = os.path.splitext(r.filename)[1].lstrip(".")
           language_name = _get_treesitter_language(ext)

           before_lines, match_lines, after_lines, is_bof, is_eof = expander.get_context_lines(
               r.filename,
               start_line,
               end_line,
               context_before=context_before or 0,
               context_after=context_after or 0,
               smart=smart_context and (context_before is None and context_after is None),
               language=language_name,
           )

           # Format context as strings (newline-separated)
           context_before_text = "\n".join(line for _, line in before_lines)
           context_after_text = "\n".join(line for _, line in after_lines)

       # Build result dict
       result_dict = {
           "file_path": r.filename,
           "start_line": start_line,
           "end_line": end_line,
           "score": r.score,
           "content": read_chunk_content(r.filename, r.start_byte, r.end_byte),
           "block_type": r.block_type,
           "hierarchy": r.hierarchy,
           "language_id": r.language_id,
           "symbol_type": r.symbol_type,
           "symbol_name": r.symbol_name,
           "symbol_signature": r.symbol_signature,
       }

       # Include context fields when context was requested
       if context_before_text or context_after_text:
           result_dict["context_before"] = context_before_text
           result_dict["context_after"] = context_after_text

       # Include hybrid search fields when available
       if r.match_type:
           result_dict["match_type"] = r.match_type
       if r.vector_score is not None:
           result_dict["vector_score"] = r.vector_score
       if r.keyword_score is not None:
           result_dict["keyword_score"] = r.keyword_score

       output.append(result_dict)

   # Clear cache after processing
   expander.clear_cache()

   return output
   ```

4. **Add helper function:**
   ```python
   def _get_treesitter_language(ext: str) -> str | None:
       """Map file extension to tree-sitter language name."""
       mapping = {
           "py": "python",
           "js": "javascript",
           "jsx": "javascript",
           "mjs": "javascript",
           "cjs": "javascript",
           "ts": "typescript",
           "tsx": "typescript",
           "mts": "typescript",
           "cts": "typescript",
           "go": "go",
           "rs": "rust",
       }
       return mapping.get(ext)
   ```

5. **Update docstring:**
   Update the function docstring to document context parameters:
   ```
   Returns code chunks matching the query, ranked by semantic similarity.
   By default, context expands to enclosing function/class boundaries.
   Use context_before/context_after to specify exact line counts.
   Set smart_context=False to disable automatic boundary expansion.
   ```
  </action>
  <verify>
`python -c "from cocosearch.mcp.server import search_code; import inspect; print([p.name for p in inspect.signature(search_code).parameters.values()])"` includes context_before, context_after, smart_context.
  </verify>
  <done>MCP search_code tool accepts context_before, context_after, and smart_context parameters.</done>
</task>

<task type="auto">
  <name>Task 2: Add MCP context parameter tests</name>
  <files>tests/unit/mcp/test_server_context.py</files>
  <action>
Create tests at `tests/unit/mcp/test_server_context.py`:

1. **Test context parameters exist:**
   - Verify search_code has context_before, context_after, smart_context params
   - Verify default values (None, None, True)

2. **Test context in response:**
   - Mock search() and ContextExpander
   - Verify context_before and context_after fields appear in response
   - Test smart_context=True expands to function boundaries
   - Test smart_context=False uses exact line counts

3. **Test parameter combinations:**
   - context_before only
   - context_after only
   - Both context_before and context_after
   - smart_context=False with no explicit counts

4. **Test edge cases:**
   - File not found (context gracefully empty)
   - No results (empty list returned)

Use existing test patterns from tests/unit/mcp/.
Mark all tests with @pytest.mark.unit.
  </action>
  <verify>`cd /Users/fedorzhdanov/GIT/personal/coco-s && python -m pytest tests/unit/mcp/test_server_context.py -v` passes.</verify>
  <done>MCP context parameter tests exist and pass.</done>
</task>

</tasks>

<verification>
1. MCP server imports work: `python -c "from cocosearch.mcp.server import search_code"`
2. Parameters exist: Check search_code signature includes context params
3. Unit tests pass: `python -m pytest tests/unit/mcp/test_server_context.py -v`
</verification>

<success_criteria>
- MCP search_code accepts context_before, context_after, smart_context parameters
- Default behavior matches CLI (smart expansion on)
- Response includes context_before and context_after string fields when context requested
- Explicit line counts override smart expansion
- All MCP context tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-context-expansion/31-03-SUMMARY.md`
</output>
