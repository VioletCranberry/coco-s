---
phase: 15-configuration-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/config/__init__.py
  - src/cocosearch/config/schema.py
  - src/cocosearch/config/loader.py
  - tests/unit/config/test_schema.py
  - tests/unit/config/test_loader.py
autonomous: true

must_haves:
  truths:
    - "Config module exports CocoSearchConfig, load_config, ConfigError"
    - "Config schema validates all CONF-02 through CONF-07 fields"
    - "Config loader discovers cocosearch.yaml in cwd or git root"
    - "Empty/missing config file returns defaults without error"
    - "Invalid YAML shows line/column in error message"
  artifacts:
    - path: "src/cocosearch/config/__init__.py"
      provides: "Public exports for config module"
      exports: ["CocoSearchConfig", "load_config", "ConfigError"]
    - path: "src/cocosearch/config/schema.py"
      provides: "Pydantic models for config schema"
      contains: "class CocoSearchConfig"
    - path: "src/cocosearch/config/loader.py"
      provides: "Config file discovery and loading"
      exports: ["find_config_file", "load_config"]
    - path: "tests/unit/config/test_schema.py"
      provides: "Schema validation tests"
      min_lines: 50
    - path: "tests/unit/config/test_loader.py"
      provides: "Loader tests"
      min_lines: 50
  key_links:
    - from: "src/cocosearch/config/__init__.py"
      to: "schema.py, loader.py"
      via: "re-exports"
      pattern: "from .schema import|from .loader import"
    - from: "src/cocosearch/config/loader.py"
      to: "schema.py"
      via: "model validation"
      pattern: "CocoSearchConfig.model_validate"
---

<objective>
Create the configuration schema and loader for CocoSearch YAML configuration.

Purpose: Enable users to configure CocoSearch behavior via `cocosearch.yaml` without CLI flags.
Output: Config module with Pydantic schema, file discovery, YAML loading, and unit tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-configuration-system/15-RESEARCH.md
@.planning/phases/15-configuration-system/15-CONTEXT.md
@src/cocosearch/indexer/config.py
@src/cocosearch/management/git.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config schema with Pydantic models</name>
  <files>
    src/cocosearch/config/__init__.py
    src/cocosearch/config/schema.py
  </files>
  <action>
Create `src/cocosearch/config/` module with schema.py containing:

1. **ConfigError** exception class for all config errors

2. **IndexingSection** model:
   - `includePatterns: list[str]` - default empty list
   - `excludePatterns: list[str]` - default empty list
   - `languages: list[str]` - default empty list (meaning all languages)
   - `chunkSize: int` - default 1000, must be > 0
   - `chunkOverlap: int` - default 300, must be >= 0
   - Use `model_config = ConfigDict(extra='forbid', strict=True)`

3. **SearchSection** model:
   - `resultLimit: int` - default 10, must be > 0
   - `minScore: float` - default 0.3, must be 0.0-1.0
   - Use `model_config = ConfigDict(extra='forbid', strict=True)`

4. **EmbeddingSection** model:
   - `model: str` - default "nomic-embed-text"
   - Use `model_config = ConfigDict(extra='forbid', strict=True)`

5. **CocoSearchConfig** root model:
   - `indexName: str | None` - default None
   - `indexing: IndexingSection` - default factory
   - `search: SearchSection` - default factory
   - `embedding: EmbeddingSection` - default factory
   - Use `model_config = ConfigDict(extra='forbid', strict=True)`

All field names use camelCase (per CONTEXT.md decision).

In __init__.py, export: `CocoSearchConfig`, `IndexingSection`, `SearchSection`, `EmbeddingSection`, `ConfigError`
  </action>
  <verify>
python -c "from cocosearch.config import CocoSearchConfig, ConfigError; c = CocoSearchConfig(); print(c.model_dump())"
  </verify>
  <done>
Schema validates correctly with defaults, rejects unknown fields with ValidationError
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config loader with file discovery</name>
  <files>
    src/cocosearch/config/loader.py
    src/cocosearch/config/__init__.py
  </files>
  <action>
Create loader.py with:

1. **find_config_file() -> Path | None**:
   - Check `Path.cwd() / "cocosearch.yaml"` first
   - Then check git root via `git rev-parse --show-toplevel`
   - Return first found, or None if no config file exists
   - Use subprocess.run with capture_output=True, text=True
   - Handle CalledProcessError gracefully (not in git repo)

2. **load_config(path: Path | None = None) -> CocoSearchConfig**:
   - If path is None, call find_config_file()
   - If no config file found, return CocoSearchConfig() (defaults)
   - Load YAML with yaml.safe_load()
   - Handle yaml.YAMLError:
     - Extract problem_mark if available for line/column
     - Raise ConfigError with "Invalid YAML syntax in {path} at line X, column Y: {problem}"
   - Handle empty file (yaml returns None) -> return defaults
   - Validate with CocoSearchConfig.model_validate(data)
   - Catch ValidationError and re-raise as ConfigError (formatting in Plan 02)

Update __init__.py to also export: `load_config`, `find_config_file`
  </action>
  <verify>
cd /tmp && python -c "from cocosearch.config import load_config; c = load_config(); print('No config:', c.model_dump())"
  </verify>
  <done>
Loader returns defaults when no config file, loads and validates YAML when present
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for schema and loader</name>
  <files>
    tests/unit/config/__init__.py
    tests/unit/config/test_schema.py
    tests/unit/config/test_loader.py
  </files>
  <action>
Create tests/unit/config/ directory with:

**test_schema.py:**
1. Test default values for all sections
2. Test valid config with all fields specified
3. Test partial config (only some sections)
4. Test unknown field rejection (extra='forbid')
5. Test type validation (strict mode - string "10" rejected for int field)
6. Test field constraints (chunkSize > 0, minScore 0-1)
7. Test nested section unknown field rejection

**test_loader.py:**
1. Test find_config_file returns None when no config exists
2. Test find_config_file finds config in cwd
3. Test find_config_file finds config in git root (use tmp git repo)
4. Test load_config returns defaults when no config file
5. Test load_config parses valid YAML
6. Test load_config handles empty YAML file
7. Test load_config raises ConfigError on invalid YAML syntax
8. Test load_config raises ConfigError on validation errors

Use pytest and tmp_path fixture for file-based tests.
Use unittest.mock.patch for subprocess calls in git root tests.
  </action>
  <verify>
pytest tests/unit/config/ -v
  </verify>
  <done>
All schema and loader tests pass, covering happy paths and error cases
  </done>
</task>

</tasks>

<verification>
1. `python -c "from cocosearch.config import CocoSearchConfig, load_config, ConfigError"` succeeds
2. `pytest tests/unit/config/ -v` passes all tests
3. Schema rejects unknown fields: `python -c "from cocosearch.config import CocoSearchConfig; CocoSearchConfig.model_validate({'unknownField': 1})"` raises ValidationError
4. Loader handles missing config: `cd /tmp && python -c "from cocosearch.config import load_config; print(load_config())"`
</verification>

<success_criteria>
- Config module is importable with all public exports
- Schema validates all required fields (CONF-02 through CONF-07)
- Loader discovers config in cwd or git root (CONF-01)
- Invalid YAML produces ConfigError with line/column
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-configuration-system/15-01-SUMMARY.md`
</output>
