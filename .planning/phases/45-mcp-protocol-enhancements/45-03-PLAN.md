---
phase: 45-mcp-protocol-enhancements
plan: 03
type: execute
wave: 3
depends_on: ["45-02"]
files_modified:
  - tests/unit/mcp/test_project_detection.py
  - tests/unit/mcp/test_server.py
  - tests/unit/mcp/test_server_context.py
autonomous: true

must_haves:
  truths:
    - "file_uri_to_path is tested for standard paths, percent-encoded paths, non-file URIs, and empty strings"
    - "_detect_project is tested for each priority level: roots, query_param, env, cwd"
    - "_detect_project is tested for fallthrough when higher-priority sources are unavailable"
    - "search_code tests pass with the new async signature (using asyncio or pytest-asyncio)"
    - "Pre-existing test_returns_success_dict and test_derives_index_name failures are fixed by adding register_index_path mock"
    - "All search_code tests in test_server.py and test_server_context.py converted to async with ctx parameter"
    - "All existing tests that were passing continue to pass"
  artifacts:
    - path: "tests/unit/mcp/test_project_detection.py"
      provides: "Unit tests for file_uri_to_path, _detect_project, register_roots_notification"
      min_lines: 100
    - path: "tests/unit/mcp/test_server.py"
      provides: "Updated tests with async support and pre-existing failure fixes"
    - path: "tests/unit/mcp/test_server_context.py"
      provides: "Updated context tests with async support and ctx parameter"
  key_links:
    - from: "tests/unit/mcp/test_project_detection.py"
      to: "src/cocosearch/mcp/project_detection.py"
      via: "direct import of functions under test"
      pattern: "from cocosearch\\.mcp\\.project_detection import"
    - from: "tests/unit/mcp/test_server.py"
      to: "src/cocosearch/mcp/server.py"
      via: "import of async tool functions"
      pattern: "from cocosearch\\.mcp\\.server import"
---

<objective>
Create comprehensive tests for the project detection module, update test_server.py for async signatures and fix pre-existing failures, and update test_server_context.py for async signatures.

Purpose: Ensure all new project detection logic is tested, existing tests pass with the async conversion, and the pre-existing register_index_path mock issue is resolved.

Output: Project detection tests and updated server/context tests, all passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-mcp-protocol-enhancements/45-CONTEXT.md
@.planning/phases/45-mcp-protocol-enhancements/45-RESEARCH.md
@.planning/phases/45-mcp-protocol-enhancements/45-01-SUMMARY.md
@.planning/phases/45-mcp-protocol-enhancements/45-02-SUMMARY.md
@src/cocosearch/mcp/project_detection.py
@src/cocosearch/mcp/server.py
@tests/unit/mcp/test_server.py
@tests/unit/mcp/test_server_context.py
@tests/conftest.py
@tests/fixtures/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_project_detection.py</name>
  <files>tests/unit/mcp/test_project_detection.py</files>
  <action>
Create `tests/unit/mcp/test_project_detection.py` with comprehensive unit tests.

**Test class: TestFileUriToPath**
Tests for `file_uri_to_path`:
- `test_standard_unix_path`: `file:///tmp/project` -> `Path("/tmp/project")`
- `test_percent_encoded_spaces`: `file:///my%20project` -> `Path("/my project")`
- `test_percent_encoded_special_chars`: `file:///path/%23special` -> `Path("/path/#special")`
- `test_non_file_uri_returns_none`: `https://example.com` -> `None`
- `test_empty_string_returns_none`: `""` -> `None`
- `test_file_uri_no_path_returns_none`: Handle edge case `file://` with no path
- `test_nested_path`: `file:///home/user/projects/my-app` -> `Path("/home/user/projects/my-app")`

**Test class: TestDetectProjectRoots (async tests)**
Tests for `_detect_project` roots priority (highest):
- `test_returns_root_path_when_roots_available`: Mock ctx.session with roots capability and list_roots returning a valid root. Assert returns (path, "roots").
- `test_skips_nonexistent_root_path`: Mock roots returning path that doesn't exist on disk. Assert falls through.
- `test_skips_when_client_has_no_roots_capability`: Mock check_client_capability returning False. Assert does NOT call list_roots.
- `test_handles_mcp_error_gracefully`: Mock list_roots raising McpError. Assert falls through without error.

For mocking `ctx`:
```python
from unittest.mock import AsyncMock, MagicMock, patch
from mcp.types import Root, ListRootsResult
from pydantic import FileUrl

def make_mock_ctx(
    has_roots=False,
    roots=None,
    roots_error=None,
    request=None,
):
    """Create a mock Context for testing _detect_project."""
    ctx = MagicMock()

    # Session mocking
    session = MagicMock()
    if has_roots:
        session.check_client_capability.return_value = True
    else:
        session.check_client_capability.return_value = False

    if roots_error:
        session.list_roots = AsyncMock(side_effect=roots_error)
    elif roots is not None:
        session.list_roots = AsyncMock(return_value=ListRootsResult(roots=roots))
    else:
        session.list_roots = AsyncMock(return_value=ListRootsResult(roots=[]))

    ctx.session = session

    # Request context mocking
    request_context = MagicMock()
    request_context.request = request
    ctx.request_context = request_context

    return ctx
```

**Test class: TestDetectProjectQueryParam (async tests)**
Tests for query_param priority (second):
- `test_returns_path_from_query_param`: Mock ctx with no roots, mock request with `query_params.get("project_path")` returning an existing absolute path. Assert returns (path, "query_param").
- `test_rejects_relative_path`: Query param with relative path. Assert falls through.
- `test_rejects_nonexistent_path`: Query param with absolute path that doesn't exist. Assert falls through.
- `test_skips_when_no_request` (stdio transport): `ctx.request_context.request` is None. Assert falls through.

For HTTP request mocking:
```python
mock_request = MagicMock()
mock_request.query_params = {"project_path": "/tmp/existing/project"}
```

**Test class: TestDetectProjectEnvVar (async tests)**
Tests for env priority (third):
- `test_returns_path_from_cocosearch_project_path_env`: Set `COCOSEARCH_PROJECT_PATH` env var. Assert returns (path, "env").
- `test_returns_path_from_cocosearch_project_env`: Set `COCOSEARCH_PROJECT` env var. Assert returns (path, "env").
- `test_cocosearch_project_path_takes_precedence`: Set both env vars. Assert `COCOSEARCH_PROJECT_PATH` wins.

Use `monkeypatch.setenv()` or `patch.dict(os.environ, ...)` and `tmp_path` for existing paths.

**Test class: TestDetectProjectCwd (async tests)**
Tests for cwd fallback (lowest):
- `test_returns_cwd_as_last_resort`: No roots, no request, no env vars. Assert returns (Path.cwd(), "cwd").

**Test class: TestDetectProjectPriorityChain (async tests)**
End-to-end priority tests:
- `test_roots_beats_query_param`: Both roots and query_param available, roots wins.
- `test_query_param_beats_env`: Both query_param and env available, query_param wins.
- `test_env_beats_cwd`: Env set, falls to env not cwd.

**Test class: TestRegisterRootsNotification**
- `test_registers_handler_on_low_level_server`: Mock FastMCP with _mcp_server.notification_handlers dict. Call register_roots_notification. Assert RootsListChangedNotification key is set.

All async tests must use `@pytest.mark.asyncio` decorator. Import `pytest` and `asyncio`.
  </action>
  <verify>
Run: `python -m pytest tests/unit/mcp/test_project_detection.py -v` -- all tests pass.
  </verify>
  <done>
- test_project_detection.py exists with tests for all three functions
- file_uri_to_path tested for standard paths, percent-encoding, edge cases
- _detect_project tested for each priority level and fallthrough behavior
- register_roots_notification tested for handler registration
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix pre-existing failures and convert test_server.py + test_server_context.py to async</name>
  <files>tests/unit/mcp/test_server.py, tests/unit/mcp/test_server_context.py</files>
  <action>
**Part A: Fix pre-existing failures in test_server.py (TestIndexCodebase)**

Two tests fail because `register_index_path` is not mocked and tries to connect to PostgreSQL:
- `TestIndexCodebase::test_returns_success_dict` (line 243)
- `TestIndexCodebase::test_derives_index_name` (line 263)

Fix by adding `register_index_path` mock to each test. The simplest approach: wrap with `patch("cocosearch.mcp.server.register_index_path")` alongside the existing `run_index` mock. Example for `test_returns_success_dict`:
```python
def test_returns_success_dict(self, tmp_codebase):
    with patch("cocoindex.init"):
        with patch("cocosearch.mcp.server.run_index") as mock_run:
            mock_run.return_value = MagicMock(stats={...})
            with patch("cocosearch.mcp.server.register_index_path"):
                result = index_codebase(...)
```

Apply same fix to `test_derives_index_name`.

**Part B: Convert test_server.py search_code tests to async**

`search_code` is now async, so any test calling it directly must use `await` and be marked `@pytest.mark.asyncio` with `async def`.

Tests affected in `TestSearchCode`:
- `test_returns_result_list` -- make async, await search_code(...)
- `test_applies_limit` -- make async, await search_code(...)
- `test_language_filter` -- make async, await search_code(...)

Tests in `TestSearchCodeMetadata`:
- `test_response_includes_metadata` -- make async, await search_code(...)
- `test_response_empty_metadata_for_non_devops` -- make async, await search_code(...)

For each of these tests, search_code now requires `ctx: Context`. Create a simple mock_ctx fixture or helper. Since these tests pass `index_name` explicitly, `_detect_project` is never called (the `if index_name is None` block is skipped). However, when calling the raw function directly in tests, you must pass `ctx` explicitly.

Add a simple fixture or helper at the top of the file:
```python
def _make_mock_ctx():
    """Create a minimal mock Context for tests that pass explicit index_name."""
    ctx = MagicMock()
    ctx.session = MagicMock()
    ctx.request_context = MagicMock()
    ctx.request_context.request = None
    return ctx
```

Then each test passes `ctx=_make_mock_ctx()` to search_code.

Tests NOT affected (no search_code call): TestListIndexes, TestIndexStats, TestClearIndex, TestIndexCodebase (these tools remain sync), TestMCPToolRegistration, TestRunServer, TestHealthEndpoint.

**Part C: Convert test_server_context.py to async**

All tests in TestContextInResponse and TestContextParameterCombinations and TestContextEdgeCases that call search_code directly need:
1. `@pytest.mark.asyncio` + `async def`
2. `await search_code(...)`
3. Pass `ctx=_make_mock_ctx()` (all these tests use explicit `index_name`)

Add the same `_make_mock_ctx()` helper at the top of test_server_context.py.

TestContextParametersExist and TestContextExpanderIntegration do NOT call search_code (they use inspect) -- no changes needed.
  </action>
  <verify>
Run:
```bash
python -m pytest tests/unit/mcp/test_server.py -v
python -m pytest tests/unit/mcp/test_server_context.py -v
```

All tests should pass, including:
- The previously-failing TestIndexCodebase::test_returns_success_dict
- The previously-failing TestIndexCodebase::test_derives_index_name
- All async-converted search_code tests
  </verify>
  <done>
- Pre-existing test failures fixed (register_index_path mock added)
- All search_code tests in test_server.py converted to async with ctx parameter
- All search_code tests in test_server_context.py converted to async with ctx parameter
- `python -m pytest tests/unit/mcp/test_server.py tests/unit/mcp/test_server_context.py -v` passes with zero failures
  </done>
</task>

<task type="auto">
  <name>Task 3: Rewrite test_server_autodetect.py mocks for _detect_project</name>
  <files>tests/unit/mcp/test_server_autodetect.py</files>
  <action>
All tests in this file call `search_code` and mock `find_project_root`. They need a more substantial rewrite because the mock targets change fundamentally:
1. Convert to async (add `@pytest.mark.asyncio`, `async def`, `await`)
2. Pass `ctx=mock_ctx` to search_code
3. Replace `patch("cocosearch.mcp.server.find_project_root", ...)` with `patch("cocosearch.mcp.project_detection._detect_project", ...)` using AsyncMock
4. Add a separate mock for the local `find_project_root` import inside search_code: mock target is `cocosearch.management.context.find_project_root` (the exact import path used in Plan 02)

The key mapping from old to new mocking:
- Old: `find_project_root` returns `(path, "git")` or `(None, None)`
- New: `_detect_project` (AsyncMock) returns `(path, "roots")` or `(path, "cwd")` -- note: _detect_project NEVER returns None, it always returns a valid Path
- New: `cocosearch.management.context.find_project_root` returns `(project_root, "git")` or `(None, None)` for the git-root walking step

Mock target for _detect_project: `cocosearch.mcp.project_detection._detect_project` (mock at the definition site, NOT at the import site in server.py, since server.py imports it via `from cocosearch.mcp.project_detection import _detect_project`).

Mock target for find_project_root: `cocosearch.management.context.find_project_root` (the exact module where it's defined, matching the local import `from cocosearch.management.context import find_project_root` in server.py's search_code function body).

For each test class:

**TestSearchCodeAutoDetect:**
- `test_auto_detects_from_cwd`: Mock _detect_project (AsyncMock) returning `(mock_root, "roots")`. Mock `cocosearch.management.context.find_project_root` returning `(mock_root, "git")`. Add ctx parameter. Make async.
- `test_returns_error_when_no_project`: Mock _detect_project returning `(some_path, "cwd")`. Mock `cocosearch.management.context.find_project_root` returning `(None, None)`. The error should come from resolve_index_name or the "index not found" check downstream. Add ctx. Make async.
- `test_returns_error_when_index_not_found`: Mock _detect_project returning `(mock_root, "roots")`. Mock find_project_root returning `(mock_root, "git")`. Add ctx. Make async.
- `test_returns_collision_error`: Same pattern, mock both _detect_project and find_project_root. Add ctx. Make async.
- `test_uses_explicit_index_name`: Add ctx, make async. _detect_project should NOT be called (index_name is provided explicitly).
- `test_no_collision_when_paths_match`: Update similarly.
- `test_logs_auto_detected_index`: Update similarly.

**TestIndexCodebasePathRegistration:** These tests call `index_codebase` which remains sync -- no changes needed.

**TestClearIndexMetadataCleanup:** These tests call `clear_index` which remains sync -- no changes needed.

**TestAutoDetectErrorResponses:** These tests call `search_code` -- update all to async with ctx and _detect_project + find_project_root mocking (same two-mock pattern as above).

Add a `_make_mock_ctx()` helper at the top of this file as well:
```python
def _make_mock_ctx():
    """Create a minimal mock Context for autodetect tests."""
    ctx = MagicMock()
    ctx.session = MagicMock()
    ctx.request_context = MagicMock()
    ctx.request_context.request = None
    return ctx
```
  </action>
  <verify>
Run:
```bash
python -m pytest tests/unit/mcp/test_server_autodetect.py -v
```

All tests should pass with the new async + _detect_project mocking pattern.
  </verify>
  <done>
- All autodetect tests converted to async with ctx parameter
- All tests mock _detect_project at `cocosearch.mcp.project_detection._detect_project` using AsyncMock
- All tests that exercise auto-detection also mock `cocosearch.management.context.find_project_root` for git-root walking
- No ambiguous mock targets -- exact module paths used throughout
- `python -m pytest tests/unit/mcp/test_server_autodetect.py -v` passes with zero failures
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/unit/mcp/test_project_detection.py -v` -- all new tests pass
2. `python -m pytest tests/unit/mcp/test_server.py -v` -- all tests pass (including previously-failing ones)
3. `python -m pytest tests/unit/mcp/test_server_autodetect.py -v` -- all tests pass with new mocking
4. `python -m pytest tests/unit/mcp/test_server_context.py -v` -- all context tests pass
5. `python -m pytest tests/unit/mcp/ -v` -- full MCP test suite green
6. `python -m pytest tests/unit/ -v` -- no regressions in other unit tests
</verification>

<success_criteria>
- test_project_detection.py has tests for file_uri_to_path (7+ tests), _detect_project (10+ tests), register_roots_notification (1+ tests)
- Pre-existing test failures in TestIndexCodebase are fixed
- All search_code tests in test_server.py use async/await with ctx parameter
- All search_code tests in test_server_context.py use async/await with ctx parameter
- All autodetect tests mock _detect_project (at cocosearch.mcp.project_detection._detect_project) instead of find_project_root
- All autodetect tests mock find_project_root at cocosearch.management.context.find_project_root for git-root walking
- Full `python -m pytest tests/unit/mcp/ -v` passes with zero failures
</success_criteria>

<output>
After completion, create `.planning/phases/45-mcp-protocol-enhancements/45-03-SUMMARY.md`
</output>
