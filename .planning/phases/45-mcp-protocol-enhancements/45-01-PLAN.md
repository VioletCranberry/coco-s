---
phase: 45-mcp-protocol-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/mcp/project_detection.py
  - src/cocosearch/mcp/__init__.py
autonomous: true

must_haves:
  truths:
    - "file_uri_to_path converts file:///path/to/dir to Path('/path/to/dir')"
    - "file_uri_to_path handles percent-encoded URIs (spaces, special chars)"
    - "_detect_project returns (path, source) tuple following roots > query_param > env > cwd priority"
    - "_detect_project gracefully handles missing Roots capability without errors"
    - "_detect_project reads project_path query param from HTTP requests"
    - "_detect_project falls through to env var COCOSEARCH_PROJECT_PATH or COCOSEARCH_PROJECT"
    - "_detect_project falls through to cwd as last resort"
    - "Roots change notification handler is registered on the low-level server"
  artifacts:
    - path: "src/cocosearch/mcp/project_detection.py"
      provides: "Project detection priority chain, file URI parsing, roots notification"
      exports: ["file_uri_to_path", "_detect_project", "register_roots_notification"]
    - path: "src/cocosearch/mcp/__init__.py"
      provides: "Updated module exports"
  key_links:
    - from: "src/cocosearch/mcp/project_detection.py"
      to: "mcp.server.fastmcp.Context"
      via: "ctx parameter in _detect_project"
      pattern: "from mcp\\.server\\.fastmcp import Context"
    - from: "src/cocosearch/mcp/project_detection.py"
      to: "mcp.types"
      via: "ClientCapabilities, RootsCapability imports"
      pattern: "from mcp\\.types import"
---

<objective>
Create the project detection module with file URI parsing, the priority-chain detection helper, and roots notification registration.

Purpose: This is the foundation for all MCP protocol enhancements -- the shared `_detect_project()` async helper that all tools will call, plus the `file_uri_to_path()` utility and roots change notification handler.

Output: New `src/cocosearch/mcp/project_detection.py` module ready for integration into server.py tools.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-mcp-protocol-enhancements/45-CONTEXT.md
@.planning/phases/45-mcp-protocol-enhancements/45-RESEARCH.md
@src/cocosearch/mcp/server.py
@src/cocosearch/mcp/__init__.py
@src/cocosearch/management/context.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project_detection.py module</name>
  <files>src/cocosearch/mcp/project_detection.py</files>
  <action>
Create `src/cocosearch/mcp/project_detection.py` with three components:

**1. `file_uri_to_path(uri: str) -> Path | None`**
- Convert `file://` URI to filesystem `Path` (Unix only, per CONTEXT.md decision)
- Use `urllib.parse.urlparse` + `urllib.parse.unquote` (NOT `FileUrl.path` -- it does NOT decode percent-encoding)
- Return `None` if URI doesn't start with `file://` or path is empty
- Example: `file:///my%20project` -> `Path("/my project")`

**2. `async def _detect_project(ctx: Context) -> tuple[Path | None, str]`**
- Priority chain: roots > query_param > env > cwd
- Returns `(path, source)` where source is one of: `"roots"`, `"query_param"`, `"env"`, `"cwd"`

Step 1 - Try MCP Roots:
- Get session via `ctx.session`
- Check client capability: `session.check_client_capability(ClientCapabilities(roots=RootsCapability()))`
- If capability exists, call `await session.list_roots()` which returns `ListRootsResult`
- Iterate `result.roots`, call `file_uri_to_path(str(root.uri))` on each
- First root with a valid, existing path wins -> return `(path, "roots")`
- If root path doesn't exist on disk, skip it silently (per CONTEXT.md: "silently skip, fall through")
- Wrap in try/except for both `McpError` and general `Exception` -- fall through on any error
- Log at debug level when roots are checked and what's found

Step 2 - Try HTTP query parameter:
- Access `ctx.request_context.request` (Starlette Request, None for stdio)
- Guard with `if request is not None` (critical: stdio has no request)
- Read `request.query_params.get("project_path")`
- Reject relative paths (`path.is_absolute()` must be True)
- Return `(path, "query_param")` if path exists on disk
- Wrap in try/except `AttributeError` for safety

Step 3 - Try environment variable:
- Check `os.environ.get("COCOSEARCH_PROJECT_PATH")` first (existing flag from --project-from-cwd)
- Then check `os.environ.get("COCOSEARCH_PROJECT")` as alternative
- Return `(path, "env")` if path exists

Step 4 - Fall back to cwd:
- Return `(Path.cwd(), "cwd")`

Add logging throughout: use `logging.getLogger(__name__)` with `logger.debug()` for each step tried and `logger.info()` when a source is selected.

**3. `def register_roots_notification(mcp_server: FastMCP) -> None`**
- Register a handler for `RootsListChangedNotification` on the low-level server
- Access via `mcp_server._mcp_server.notification_handlers[RootsListChangedNotification]`
- The handler is an async function that logs "Roots list changed, will re-detect on next tool call"
- No caching needed -- `_detect_project()` is called fresh each time (per RESEARCH.md recommendation)

Imports needed:
```python
import logging
import os
from pathlib import Path
from urllib.parse import unquote, urlparse

from mcp.server.fastmcp import Context, FastMCP
from mcp.shared.exceptions import McpError
from mcp.types import ClientCapabilities, RootsCapability, RootsListChangedNotification
```
  </action>
  <verify>
Run: `python -c "from cocosearch.mcp.project_detection import file_uri_to_path, _detect_project, register_roots_notification; print('imports OK')"` succeeds.

Verify `file_uri_to_path`:
- `file_uri_to_path("file:///tmp/test")` returns `Path("/tmp/test")`
- `file_uri_to_path("file:///my%20project")` returns `Path("/my project")`
- `file_uri_to_path("https://example.com")` returns `None`
- `file_uri_to_path("")` returns `None`
  </verify>
  <done>
- `project_detection.py` exists with all three public functions
- `file_uri_to_path` correctly parses file:// URIs with percent-decoding
- `_detect_project` is async and follows the 4-step priority chain
- `register_roots_notification` sets up the notification handler on the low-level server
- All imports resolve without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update mcp/__init__.py exports</name>
  <files>src/cocosearch/mcp/__init__.py</files>
  <action>
Update `src/cocosearch/mcp/__init__.py` to export the new module's public API:

```python
from cocosearch.mcp.project_detection import (
    file_uri_to_path,
    _detect_project,
    register_roots_notification,
)
from cocosearch.mcp.server import mcp, run_server

__all__ = [
    "mcp",
    "run_server",
    "file_uri_to_path",
    "_detect_project",
    "register_roots_notification",
]
```

Keep docstring at top of file. The underscore prefix on `_detect_project` is intentional -- it's "private" to the MCP package but needs to be importable by server.py within the package.
  </action>
  <verify>
Run: `python -c "from cocosearch.mcp import file_uri_to_path, _detect_project, register_roots_notification; print('module exports OK')"` succeeds.
  </verify>
  <done>
- `__init__.py` exports all new functions alongside existing `mcp` and `run_server`
- Imports from `cocosearch.mcp` work for all public symbols
  </done>
</task>

</tasks>

<verification>
1. `python -c "from cocosearch.mcp.project_detection import file_uri_to_path, _detect_project, register_roots_notification"` -- imports succeed
2. `python -c "from cocosearch.mcp import file_uri_to_path"` -- package-level export works
3. `python -c "from cocosearch.mcp.project_detection import file_uri_to_path; assert file_uri_to_path('file:///tmp/test').as_posix() == '/tmp/test'"` -- URI parsing works
4. `python -c "from cocosearch.mcp.project_detection import file_uri_to_path; assert file_uri_to_path('file:///my%20project').as_posix() == '/my project'"` -- percent decoding works
5. `python -c "import asyncio; from cocosearch.mcp.project_detection import _detect_project; assert asyncio.iscoroutinefunction(_detect_project)"` -- _detect_project is async
</verification>

<success_criteria>
- project_detection.py module exists with file_uri_to_path, _detect_project, and register_roots_notification
- file_uri_to_path correctly handles file:// URIs with percent-decoding
- _detect_project is async and implements the full priority chain (roots > query_param > env > cwd)
- register_roots_notification hooks into the low-level server's notification_handlers
- All imports resolve cleanly from both module and package level
</success_criteria>

<output>
After completion, create `.planning/phases/45-mcp-protocol-enhancements/45-01-SUMMARY.md`
</output>
