---
phase: 46-parse-failure-tracking
plan: 03
type: execute
wave: 3
depends_on: ["46-02"]
files_modified:
  - src/cocosearch/mcp/server.py
  - tests/unit/indexer/test_parse_tracking.py
  - tests/unit/management/test_stats.py
autonomous: true

must_haves:
  truths:
    - "MCP index_stats tool returns parse_stats in its response"
    - "HTTP /api/stats endpoint returns parse_stats in its JSON response"
    - "MCP index_stats with include_failures=true returns individual file failures"
    - "HTTP /api/stats?include_failures=true returns individual file failures"
    - "detect_parse_status() is tested for ok, partial, error, and unsupported cases"
    - "get_parse_stats() is tested with mock database for aggregation logic"
    - "Pre-v46 indexes return empty parse_stats without errors in MCP/HTTP"
  artifacts:
    - path: "src/cocosearch/mcp/server.py"
      provides: "Updated index_stats tool with parse stats and include_failures parameter, updated /api/stats with parse data"
      contains: "parse_stats"
    - path: "tests/unit/indexer/test_parse_tracking.py"
      provides: "Tests for detect_parse_status and _collect_error_lines"
      min_lines: 60
    - path: "tests/unit/management/test_stats.py"
      provides: "Tests for get_parse_stats, get_parse_failures, updated IndexStats"
      contains: "TestGetParseStats"
  key_links:
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/management/stats.py"
      via: "get_comprehensive_stats().to_dict() includes parse_stats"
      pattern: "get_comprehensive_stats"
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/management/stats.py"
      via: "get_parse_failures() for optional detail inclusion"
      pattern: "get_parse_failures"
---

<objective>
Surface parse failure stats through MCP and HTTP endpoints, and add comprehensive tests for the parse tracking module and stats functions.

Purpose: Completes the observability surface area (MCP clients like Claude and HTTP consumers get parse health data) and ensures all new code is tested.
Output: Updated server.py with parse stats in all stats endpoints, new test file for parse_tracking, updated test_stats.py with parse stats tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-parse-failure-tracking/46-CONTEXT.md
@.planning/phases/46-parse-failure-tracking/46-RESEARCH.md
@.planning/phases/46-parse-failure-tracking/46-01-SUMMARY.md
@.planning/phases/46-parse-failure-tracking/46-02-SUMMARY.md
@src/cocosearch/mcp/server.py
@tests/unit/management/test_stats.py
@tests/mocks/db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MCP index_stats tool and HTTP /api/stats endpoint with parse stats</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
**1. Update the `index_stats` MCP tool:**

Modify the `index_stats` function to return comprehensive stats (which now include parse_stats) instead of basic stats. Also add an optional `include_failures` parameter.

Replace the current `index_stats` function with:

```python
@mcp.tool()
def index_stats(
    index_name: Annotated[
        str | None,
        Field(description="Name of the index (omit for all indexes)"),
    ] = None,
    include_failures: Annotated[
        bool,
        Field(
            description="Include individual file parse failure details. "
            "When True, adds a 'parse_failures' list with file paths, languages, statuses, and error messages."
        ),
    ] = False,
) -> dict | list[dict]:
    """Get statistics for code indexes including parse health.

    Returns file count, chunk count, storage size, language distribution,
    symbol counts, and parse failure breakdown per language.
    If index_name is provided, returns stats for that index only.
    Otherwise, returns stats for all indexes.
    """
    # Initialize CocoIndex (required for database connection)
    cocoindex.init()

    try:
        if index_name:
            stats = get_comprehensive_stats(index_name)
            result = stats.to_dict()
            if include_failures:
                from cocosearch.management.stats import get_parse_failures
                result["parse_failures"] = get_parse_failures(index_name)
            return result
        else:
            # Get stats for all indexes
            indexes = mgmt_list_indexes()
            all_stats = []
            for idx in indexes:
                try:
                    stats = get_comprehensive_stats(idx["name"])
                    result = stats.to_dict()
                    if include_failures:
                        from cocosearch.management.stats import get_parse_failures
                        result["parse_failures"] = get_parse_failures(idx["name"])
                    all_stats.append(result)
                except ValueError:
                    pass
            return all_stats
    except ValueError as e:
        return {"success": False, "error": str(e)}
```

Note: This changes `index_stats` from using `get_stats()` (basic) to `get_comprehensive_stats()` (comprehensive, includes parse_stats). This is an enhancement -- the tool now returns richer data. Add `cocoindex.init()` at the top of the function since `get_comprehensive_stats` needs DB access.

**2. Update the HTTP `/api/stats` endpoint:**

The `/api/stats` route already uses `get_comprehensive_stats().to_dict()`, which now includes `parse_stats` via Plan 02. No changes needed for basic parse stats.

Add optional `include_failures` query parameter support. In the `api_stats` function, for both the single-index and all-indexes paths:

For single-index path (after `stats = get_comprehensive_stats(index_name)`):
```python
            result = stats.to_dict()
            # Include individual failure details if requested
            include_failures = request.query_params.get("include_failures", "").lower() == "true"
            if include_failures:
                from cocosearch.management.stats import get_parse_failures
                result["parse_failures"] = get_parse_failures(index_name)
            return JSONResponse(
                result,
                headers={"Cache-Control": "no-cache, no-store, must-revalidate"}
            )
```

For all-indexes path, similarly check `include_failures` and add failure details to each index's stats dict before appending to `all_stats`.

Also update the `/api/stats/{index_name}` route with the same `include_failures` parameter support.

**3. Add import for `get_parse_failures`:**

Add `get_parse_failures` to the imports from `cocosearch.management.stats` at the top of the file. Update the existing import line:
```python
from cocosearch.management.stats import check_staleness, get_comprehensive_stats, get_parse_failures
```

Or use local imports within the functions as shown above (either approach works; prefer the top-level import for consistency if the function is always available).
  </action>
  <verify>
Run `python -c "from cocosearch.mcp.server import mcp; print('server imports ok')"` to verify the server module loads cleanly.

Run `grep -n 'parse_stats\|parse_failures\|include_failures\|get_parse_failures' src/cocosearch/mcp/server.py` to confirm all parse-related changes are present.

Run `grep -n 'get_comprehensive_stats' src/cocosearch/mcp/server.py` to verify index_stats now uses comprehensive stats.
  </verify>
  <done>
  - MCP index_stats tool returns comprehensive stats including parse_stats
  - MCP index_stats tool accepts include_failures parameter for detailed failure list
  - HTTP /api/stats includes parse_stats in JSON response
  - HTTP /api/stats accepts ?include_failures=true query parameter
  - HTTP /api/stats/{index_name} also supports include_failures
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for parse_tracking module and parse stats functions</name>
  <files>
    tests/unit/indexer/test_parse_tracking.py
    tests/unit/management/test_stats.py
  </files>
  <action>
**1. Create `tests/unit/indexer/test_parse_tracking.py`:**

Test the `detect_parse_status` and `_collect_error_lines` functions. These do NOT need database mocks -- they are pure functions operating on strings and tree-sitter trees.

```python
"""Tests for parse failure tracking module."""

import pytest
from cocosearch.indexer.parse_tracking import detect_parse_status, _collect_error_lines


class TestDetectParseStatus:
    """Tests for detect_parse_status function."""

    def test_ok_for_valid_python(self):
        """Returns ('ok', None) for syntactically valid Python."""
        status, msg = detect_parse_status("def foo():\n    pass\n", "py")
        assert status == "ok"
        assert msg is None

    def test_ok_for_valid_javascript(self):
        """Returns ('ok', None) for valid JavaScript."""
        status, msg = detect_parse_status("function foo() { return 1; }", "js")
        assert status == "ok"
        assert msg is None

    def test_ok_for_valid_typescript(self):
        """Returns ('ok', None) for valid TypeScript."""
        status, msg = detect_parse_status("const x: number = 1;", "ts")
        assert status == "ok"
        assert msg is None

    def test_partial_for_broken_python(self):
        """Returns ('partial', error_msg) for Python with syntax errors."""
        status, msg = detect_parse_status("def foo(:\n    pass", "py")
        assert status == "partial"
        assert msg is not None
        assert "ERROR" in msg

    def test_partial_includes_line_numbers(self):
        """Error message includes line numbers of ERROR nodes."""
        status, msg = detect_parse_status("def foo(:\n    pass", "py")
        assert status == "partial"
        # Should contain at least one line number
        assert any(c.isdigit() for c in msg)

    def test_unsupported_for_unknown_extension(self):
        """Returns ('unsupported', None) for extensions not in LANGUAGE_MAP."""
        status, msg = detect_parse_status("FROM ubuntu:latest", "dockerfile")
        assert status == "unsupported"
        assert msg is None

    def test_unsupported_for_empty_extension(self):
        """Returns ('unsupported', None) for empty extension."""
        status, msg = detect_parse_status("some content", "")
        assert status == "unsupported"
        assert msg is None

    def test_unsupported_for_unknown_lang(self):
        """Returns ('unsupported', None) for completely unknown extensions."""
        status, msg = detect_parse_status("some content", "zzz")
        assert status == "unsupported"
        assert msg is None

    def test_ok_for_valid_go(self):
        """Returns ('ok', None) for valid Go code."""
        status, msg = detect_parse_status("package main\n\nfunc main() {}\n", "go")
        assert status == "ok"
        assert msg is None

    def test_ok_for_valid_rust(self):
        """Returns ('ok', None) for valid Rust code."""
        status, msg = detect_parse_status("fn main() {}\n", "rs")
        assert status == "ok"
        assert msg is None

    def test_handles_empty_content(self):
        """Does not crash on empty string input."""
        status, msg = detect_parse_status("", "py")
        # Empty content should parse ok (empty tree has no errors)
        assert status == "ok"
        assert msg is None


class TestCollectErrorLines:
    """Tests for _collect_error_lines helper."""

    def test_returns_empty_for_valid_tree(self):
        """Returns empty list when tree has no error nodes."""
        from tree_sitter_language_pack import get_parser
        parser = get_parser("python")
        tree = parser.parse(b"x = 1")
        lines = _collect_error_lines(tree.root_node)
        assert lines == []

    def test_returns_line_numbers_for_errors(self):
        """Returns line numbers of ERROR nodes."""
        from tree_sitter_language_pack import get_parser
        parser = get_parser("python")
        tree = parser.parse(b"def foo(:\n    pass")
        lines = _collect_error_lines(tree.root_node)
        assert len(lines) > 0
        # All lines should be positive integers (1-indexed)
        assert all(isinstance(l, int) and l >= 1 for l in lines)
```

First check if `tests/unit/indexer/` directory exists. If not, create it along with `__init__.py`.

**2. Update `tests/unit/management/test_stats.py`:**

Add test classes for the new parse stats functions. Add these at the end of the file:

```python
class TestGetParseStats:
    """Tests for get_parse_stats function."""

    def test_returns_aggregated_stats(self, mock_db_pool):
        """Returns per-language breakdown with correct structure."""
        pool, cursor, conn = mock_db_pool(
            results=[
                (True,),  # Table exists
                ("python", "ok", 100),
                ("python", "partial", 5),
                ("python", "error", 2),
                ("javascript", "ok", 50),
            ]
        )

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            stats = get_parse_stats("test")

        assert "by_language" in stats
        assert "python" in stats["by_language"]
        assert stats["by_language"]["python"]["ok"] == 100
        assert stats["by_language"]["python"]["partial"] == 5
        assert stats["by_language"]["python"]["error"] == 2
        assert stats["by_language"]["javascript"]["ok"] == 50
        assert stats["total_files"] == 157
        assert stats["total_ok"] == 150
        assert stats["parse_health_pct"] == round(150 / 157 * 100, 1)

    def test_returns_empty_for_missing_table(self, mock_db_pool):
        """Returns empty dict when parse_results table doesn't exist."""
        pool, cursor, conn = mock_db_pool(results=[(False,)])  # Table doesn't exist

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            stats = get_parse_stats("old_index")

        assert stats == {}

    def test_returns_100_percent_for_all_ok(self, mock_db_pool):
        """Returns 100% health when all files parse ok."""
        pool, cursor, conn = mock_db_pool(
            results=[
                (True,),  # Table exists
                ("python", "ok", 50),
            ]
        )

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            stats = get_parse_stats("test")

        assert stats["parse_health_pct"] == 100.0

    def test_returns_100_percent_for_empty_table(self, mock_db_pool):
        """Returns 100% health when no files are tracked."""
        pool, cursor, conn = mock_db_pool(
            results=[
                (True,),  # Table exists
                # No rows from aggregation
            ]
        )

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            stats = get_parse_stats("test")

        assert stats["parse_health_pct"] == 100.0
        assert stats["total_files"] == 0


class TestGetParseFailures:
    """Tests for get_parse_failures function."""

    def test_returns_failure_details(self, mock_db_pool):
        """Returns list of failure dicts for non-ok files."""
        pool, cursor, conn = mock_db_pool(
            results=[
                (True,),  # Table exists
                ("src/broken.py", "python", "error", "SyntaxError"),
                ("src/partial.js", "javascript", "partial", "ERROR nodes at lines: 5"),
            ]
        )

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            failures = get_parse_failures("test")

        assert len(failures) == 2
        assert failures[0]["file_path"] == "src/broken.py"
        assert failures[0]["parse_status"] == "error"
        assert failures[1]["parse_status"] == "partial"

    def test_returns_empty_for_missing_table(self, mock_db_pool):
        """Returns empty list when table doesn't exist."""
        pool, cursor, conn = mock_db_pool(results=[(False,)])

        with patch(
            "cocosearch.management.stats.get_connection_pool", return_value=pool
        ):
            failures = get_parse_failures("old_index")

        assert failures == []


class TestIndexStatsWithParseStats:
    """Tests for IndexStats with parse_stats field."""

    def test_to_dict_includes_parse_stats(self):
        """to_dict() includes parse_stats in output."""
        stats = IndexStats(
            name="test",
            file_count=10,
            chunk_count=50,
            storage_size=1024,
            storage_size_pretty="1.0 KB",
            created_at=None,
            updated_at=None,
            is_stale=False,
            staleness_days=0,
            languages=[],
            symbols={},
            warnings=[],
            parse_stats={"by_language": {"python": {"files": 10, "ok": 9, "partial": 1, "error": 0, "unsupported": 0}}, "parse_health_pct": 90.0, "total_files": 10, "total_ok": 9},
        )
        d = stats.to_dict()
        assert "parse_stats" in d
        assert d["parse_stats"]["parse_health_pct"] == 90.0

    def test_to_dict_with_empty_parse_stats(self):
        """to_dict() handles empty parse_stats (pre-v46 indexes)."""
        stats = IndexStats(
            name="test",
            file_count=10,
            chunk_count=50,
            storage_size=1024,
            storage_size_pretty="1.0 KB",
            created_at=None,
            updated_at=None,
            is_stale=False,
            staleness_days=0,
            languages=[],
            symbols={},
            warnings=[],
            parse_stats={},
        )
        d = stats.to_dict()
        assert d["parse_stats"] == {}
```

Add the new imports at the top of test_stats.py:
```python
from cocosearch.management.stats import (
    IndexStats,
    check_staleness,
    collect_warnings,
    format_bytes,
    get_comprehensive_stats,
    get_parse_failures,
    get_parse_stats,
    get_stats,
    get_symbol_stats,
)
```

IMPORTANT: The existing `TestIndexStats` test class creates `IndexStats` without the new `parse_stats` field. Update those two existing test methods (`test_instantiation_with_all_fields` and `test_to_dict_serialization` and `test_to_dict_with_none_datetimes`) to include `parse_stats={}` in their IndexStats constructor calls to avoid TypeError from the new required field.
  </action>
  <verify>
Run `python -m pytest tests/unit/indexer/test_parse_tracking.py -v` to verify all parse tracking tests pass.

Run `python -m pytest tests/unit/management/test_stats.py -v` to verify all stats tests pass (including existing tests updated for parse_stats field).

Run `python -m pytest tests/unit/ -v --tb=short 2>&1 | tail -30` to verify no regressions in the full unit test suite.
  </verify>
  <done>
  - MCP index_stats returns comprehensive stats with parse_stats
  - HTTP /api/stats returns parse_stats in JSON
  - include_failures parameter works in both MCP and HTTP
  - test_parse_tracking.py tests ok/partial/error/unsupported detection
  - test_stats.py tests get_parse_stats() and get_parse_failures() with mock DB
  - Existing IndexStats tests updated for new parse_stats field
  - All tests pass with no regressions
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/unit/ -v --tb=short` -- all tests pass
2. MCP server module imports cleanly
3. index_stats tool returns parse_stats in response
4. /api/stats endpoint includes parse_stats
5. include_failures parameter works for both MCP tool and HTTP endpoint
6. test_parse_tracking.py covers ok, partial, error, unsupported cases
7. test_stats.py covers get_parse_stats aggregation and get_parse_failures
8. No regressions in existing tests
</verification>

<success_criteria>
- MCP index_stats tool uses get_comprehensive_stats() and returns parse_stats
- HTTP /api/stats includes parse_stats in JSON response
- include_failures parameter available on MCP tool and HTTP endpoint
- test_parse_tracking.py exists with 10+ test methods covering all parse statuses
- test_stats.py has TestGetParseStats and TestGetParseFailures test classes
- Existing IndexStats tests updated for parse_stats field
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/46-parse-failure-tracking/46-03-SUMMARY.md`
</output>
