---
phase: 03-search
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/cocosearch/search/formatter.py
  - src/cocosearch/search/utils.py
  - src/cocosearch/search/__init__.py
  - src/cocosearch/cli.py

autonomous: true

must_haves:
  truths:
    - "User can search with natural language query via CLI"
    - "Results show file path and line numbers"
    - "Results show similarity scores"
    - "User can limit number of results"
    - "User can filter by programming language"
    - "Default output is JSON, --pretty flag shows formatted output"
  artifacts:
    - path: "src/cocosearch/search/formatter.py"
      provides: "JSON and pretty output formatters"
      exports: ["format_json", "format_pretty"]
    - path: "src/cocosearch/search/utils.py"
      provides: "Byte offset to line number conversion"
      exports: ["byte_to_line", "read_chunk_content", "get_context_lines"]
    - path: "src/cocosearch/cli.py"
      provides: "Extended CLI with search command"
      contains: "def search_command"
  key_links:
    - from: "src/cocosearch/cli.py"
      to: "src/cocosearch/search/query.py"
      via: "search() function call"
      pattern: "from cocosearch\\.search import search"
    - from: "src/cocosearch/search/formatter.py"
      to: "src/cocosearch/search/utils.py"
      via: "byte_to_line for line numbers"
      pattern: "from.*utils.*import.*byte_to_line"
---

<objective>
Extend CLI with search command and result formatting.

Purpose: Enable users to search indexed code from command line with human-readable or JSON output.
Output: Working `cocosearch 'query'` command with all flags from CONTEXT.md.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search/03-CONTEXT.md
@.planning/phases/03-search/03-RESEARCH.md
@.planning/phases/03-search/03-01-SUMMARY.md

# Existing code to extend
@src/cocosearch/cli.py
@src/cocosearch/indexer/progress.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create utility functions for result processing</name>
  <files>src/cocosearch/search/utils.py, src/cocosearch/search/__init__.py</files>
  <action>
Create `src/cocosearch/search/utils.py` with:

1. **Byte offset to line number conversion:**
```python
def byte_to_line(filepath: str, byte_offset: int) -> int:
    """Convert byte offset to 1-based line number.

    Args:
        filepath: Path to the source file.
        byte_offset: Byte offset in the file.

    Returns:
        1-based line number.
    """
    try:
        with open(filepath, 'rb') as f:
            content = f.read(byte_offset)
            return content.count(b'\n') + 1
    except (FileNotFoundError, IOError):
        return 0  # File not accessible
```

2. **Read chunk content from source file:**
```python
def read_chunk_content(filepath: str, start_byte: int, end_byte: int) -> str:
    """Read chunk content from source file.

    Args:
        filepath: Path to the source file.
        start_byte: Start byte offset.
        end_byte: End byte offset.

    Returns:
        Chunk text content, or empty string if file not accessible.
    """
    try:
        with open(filepath, 'rb') as f:
            f.seek(start_byte)
            content = f.read(end_byte - start_byte)
            return content.decode('utf-8', errors='replace')
    except (FileNotFoundError, IOError):
        return ""
```

3. **Get context lines around chunk:**
```python
def get_context_lines(
    filepath: str,
    start_line: int,
    end_line: int,
    context: int = 5
) -> tuple[list[str], list[str]]:
    """Get lines before and after a code chunk.

    Args:
        filepath: Path to the source file.
        start_line: 1-based start line of chunk.
        end_line: 1-based end line of chunk.
        context: Number of context lines to include.

    Returns:
        Tuple of (lines_before, lines_after).
    """
    try:
        with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
            all_lines = f.readlines()

        # Calculate context ranges (0-indexed)
        before_start = max(0, start_line - 1 - context)
        before_end = start_line - 1
        after_start = end_line
        after_end = min(len(all_lines), end_line + context)

        lines_before = all_lines[before_start:before_end]
        lines_after = all_lines[after_start:after_end]

        return (
            [line.rstrip('\n\r') for line in lines_before],
            [line.rstrip('\n\r') for line in lines_after]
        )
    except (FileNotFoundError, IOError):
        return ([], [])
```

Update `__init__.py` to export these utilities.
  </action>
  <verify>
```bash
uv run python -c "
from cocosearch.search.utils import byte_to_line, read_chunk_content

# Test with a known file
import os
test_file = 'src/cocosearch/__init__.py'
if os.path.exists(test_file):
    # First newline should give line 2
    with open(test_file, 'rb') as f:
        content = f.read()
        first_newline = content.find(b'\n')
    line_num = byte_to_line(test_file, first_newline + 1)
    print(f'Byte {first_newline + 1} is line {line_num}')

    # Read first 50 bytes
    chunk = read_chunk_content(test_file, 0, min(50, len(content)))
    print(f'First chunk: {repr(chunk[:30])}...')
"
  </verify>
  <done>Utility functions for byte-to-line conversion and chunk reading implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create result formatter module</name>
  <files>src/cocosearch/search/formatter.py, src/cocosearch/search/__init__.py</files>
  <action>
Create `src/cocosearch/search/formatter.py` with:

1. **JSON formatter:**
```python
import json
from cocosearch.search.query import SearchResult
from cocosearch.search.utils import byte_to_line, read_chunk_content, get_context_lines

def format_json(
    results: list[SearchResult],
    context_lines: int = 5,
    include_content: bool = True,
) -> str:
    """Format results as JSON.

    Args:
        results: List of SearchResult objects.
        context_lines: Number of surrounding lines to include.
        include_content: Whether to include chunk content.

    Returns:
        JSON string.
    """
    output = []
    for r in results:
        start_line = byte_to_line(r.filename, r.start_byte)
        end_line = byte_to_line(r.filename, r.end_byte)

        item = {
            "file_path": r.filename,
            "start_line": start_line,
            "end_line": end_line,
            "score": round(r.score, 4),
        }

        if include_content:
            item["content"] = read_chunk_content(r.filename, r.start_byte, r.end_byte)

            if context_lines > 0:
                before, after = get_context_lines(r.filename, start_line, end_line, context_lines)
                item["context_before"] = before
                item["context_after"] = after

        output.append(item)

    return json.dumps(output, indent=2)
```

2. **Pretty formatter using Rich:**
```python
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.text import Text
import os

def format_pretty(
    results: list[SearchResult],
    context_lines: int = 5,
    console: Console | None = None,
) -> None:
    """Print results in human-readable format.

    Args:
        results: List of SearchResult objects.
        context_lines: Number of surrounding lines to include.
        console: Rich Console instance (creates new if None).
    """
    if console is None:
        console = Console()

    if not results:
        console.print("[dim]No results found.[/dim]")
        return

    console.print(f"[bold]Found {len(results)} results:[/bold]\n")

    # Group results by file
    by_file: dict[str, list[SearchResult]] = {}
    for r in results:
        if r.filename not in by_file:
            by_file[r.filename] = []
        by_file[r.filename].append(r)

    for filepath, file_results in by_file.items():
        # File header
        rel_path = os.path.relpath(filepath) if os.path.exists(filepath) else filepath
        console.print(f"[bold blue]{rel_path}[/bold blue]")

        for r in file_results:
            start_line = byte_to_line(r.filename, r.start_byte)
            end_line = byte_to_line(r.filename, r.end_byte)

            # Score and line info
            score_color = "green" if r.score > 0.7 else "yellow" if r.score > 0.5 else "red"
            console.print(f"  [{score_color}]{r.score:.2f}[/{score_color}] Lines {start_line}-{end_line}")

            # Show content with syntax highlighting
            content = read_chunk_content(r.filename, r.start_byte, r.end_byte)
            if content:
                # Determine language from extension
                ext = os.path.splitext(filepath)[1].lstrip('.')
                lang_map = {
                    'py': 'python', 'js': 'javascript', 'ts': 'typescript',
                    'rs': 'rust', 'go': 'go', 'java': 'java', 'rb': 'ruby',
                    'php': 'php', 'c': 'c', 'cpp': 'cpp', 'h': 'c',
                    'cs': 'csharp', 'swift': 'swift', 'kt': 'kotlin',
                    'scala': 'scala', 'sh': 'bash', 'bash': 'bash',
                }
                lang = lang_map.get(ext, ext)

                try:
                    syntax = Syntax(
                        content,
                        lang,
                        line_numbers=True,
                        start_line=start_line,
                        theme="monokai",
                    )
                    console.print(syntax)
                except Exception:
                    # Fallback to plain text if syntax highlighting fails
                    console.print(content)

        console.print()  # Blank line between files
```

Update `__init__.py` to export formatters.
  </action>
  <verify>
```bash
uv run python -c "
from cocosearch.search.formatter import format_json, format_pretty
from cocosearch.search.query import SearchResult

# Test with mock data
mock_results = [
    SearchResult(
        filename='src/cocosearch/__init__.py',
        start_byte=0,
        end_byte=50,
        score=0.85
    )
]

# Test JSON formatter
json_out = format_json(mock_results, context_lines=2)
print('JSON output:')
print(json_out[:200])
"
  </verify>
  <done>JSON and pretty formatters implemented with syntax highlighting and grouping by file</done>
</task>

<task type="auto">
  <name>Task 3: Extend CLI with search command</name>
  <files>src/cocosearch/cli.py</files>
  <action>
Extend `src/cocosearch/cli.py` to add the search command:

1. **Add search_command function:**
```python
import cocoindex
import re as regex_module
from cocosearch.search import search, SearchResult
from cocosearch.search.formatter import format_json, format_pretty

def parse_query_filters(query: str) -> tuple[str, str | None]:
    """Parse inline filters from query string.

    Extracts lang:xxx pattern from query.

    Args:
        query: User query possibly containing filters.

    Returns:
        Tuple of (clean_query, language_filter).
    """
    lang_filter = None

    # Extract lang:xxx pattern
    lang_match = regex_module.search(r'\blang:(\w+)\b', query)
    if lang_match:
        lang_filter = lang_match.group(1)
        query = regex_module.sub(r'\blang:\w+\b', '', query).strip()

    return query, lang_filter

def search_command(args: argparse.Namespace) -> int:
    """Execute the search command."""
    console = Console()

    # Initialize CocoIndex
    cocoindex.init()

    # Determine index name
    if args.index:
        index_name = args.index
    else:
        # Auto-detect from cwd
        index_name = derive_index_name(os.getcwd())
        if not args.pretty:
            # Only show in pretty mode to keep JSON clean
            pass
        else:
            console.print(f"[dim]Using index: {index_name}[/dim]")

    # Parse query for inline filters
    query, inline_lang = parse_query_filters(args.query)

    # CLI --lang overrides inline lang:
    lang_filter = args.lang or inline_lang

    # Execute search
    try:
        results = search(
            query=query,
            index_name=index_name,
            limit=args.limit,
            min_score=args.min_score,
            language_filter=lang_filter,
        )
    except Exception as e:
        if args.pretty:
            console.print(f"[bold red]Error:[/bold red] {e}")
        else:
            print(json.dumps({"error": str(e)}))
        return 1

    # Output results
    if args.pretty:
        format_pretty(results, context_lines=args.context, console=console)
    else:
        print(format_json(results, context_lines=args.context))

    return 0
```

2. **Update main() to add search as default action:**
Modify argument parser so query is the default (no subcommand needed):

```python
def main() -> None:
    parser = argparse.ArgumentParser(
        prog="cocosearch",
        description="Local-first semantic code search",
    )

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Index subcommand (existing)
    index_parser = subparsers.add_parser("index", ...)  # keep existing

    # Search subcommand (also works as default)
    search_parser = subparsers.add_parser(
        "search",
        help="Search indexed code (also works as default action)",
    )
    search_parser.add_argument("query", help="Natural language search query")
    search_parser.add_argument(
        "-n", "--index",
        help="Index name (default: auto-detect from cwd)",
    )
    search_parser.add_argument(
        "-l", "--limit",
        type=int,
        default=10,
        help="Maximum results (default: 10)",
    )
    search_parser.add_argument(
        "--lang",
        help="Filter by language (e.g., python, typescript)",
    )
    search_parser.add_argument(
        "--min-score",
        type=float,
        default=0.3,
        help="Minimum similarity score 0-1 (default: 0.3)",
    )
    search_parser.add_argument(
        "-c", "--context",
        type=int,
        default=5,
        help="Context lines to include (default: 5)",
    )
    search_parser.add_argument(
        "--pretty",
        action="store_true",
        help="Human-readable output (default: JSON)",
    )

    # Parse args
    args = parser.parse_args()

    # Handle default action (query without subcommand)
    if args.command is None:
        # Check if first positional looks like a query (not a subcommand)
        if len(sys.argv) > 1 and sys.argv[1] not in ["index", "search", "-h", "--help"]:
            # Re-parse with "search" inserted
            sys.argv.insert(1, "search")
            args = parser.parse_args()

    if args.command == "index":
        sys.exit(index_command(args))
    elif args.command == "search":
        sys.exit(search_command(args))
    else:
        parser.print_help()
        sys.exit(1)
```

**Note:** Add `import json` at top of file for error output.
  </action>
  <verify>
```bash
# Test CLI help
uv run cocosearch search --help

# Test with no index (should show helpful error or auto-detect)
# This will fail if no index exists, which is expected
uv run cocosearch search "test query" --pretty 2>&1 | head -5

# Test default action (query without subcommand)
uv run cocosearch "test query" --pretty 2>&1 | head -5
  </verify>
  <done>CLI extended with search command, all flags from CONTEXT.md, and default action behavior</done>
</task>

</tasks>

<verification>
After all tasks complete, verify full CLI search flow:

```bash
# Ensure infrastructure is running
docker compose up -d

export COCOINDEX_DATABASE_URL="postgresql://cocoindex:cocoindex@localhost:5432/cocoindex"

# Index current project if not already indexed
uv run cocosearch index . --name cocosearch_test

# Test JSON output (default)
uv run cocosearch search "indexing files" --index cocosearch_test --limit 3

# Test pretty output
uv run cocosearch "indexing files" --index cocosearch_test --limit 3 --pretty

# Test language filter
uv run cocosearch "config" --index cocosearch_test --lang python --pretty

# Test inline lang: syntax
uv run cocosearch "config lang:python" --index cocosearch_test --pretty
```
</verification>

<success_criteria>
- [ ] `cocosearch search 'query'` works with all flags
- [ ] `cocosearch 'query'` works as default action (no subcommand)
- [ ] JSON output includes file_path, start_line, end_line, score, content
- [ ] `--pretty` flag shows Rich-formatted output with syntax highlighting
- [ ] `--limit N` limits results
- [ ] `--lang python` filters by language
- [ ] `lang:python` inline syntax works in query
- [ ] `--context N` controls surrounding lines
- [ ] `--min-score` filters low-scoring results
- [ ] Auto-detects index from cwd when `--index` not specified
</success_criteria>

<output>
After completion, create `.planning/phases/03-search/03-02-SUMMARY.md`
</output>
