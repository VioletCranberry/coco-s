---
phase: 03-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/search/__init__.py
  - src/cocosearch/search/db.py
  - src/cocosearch/search/query.py

autonomous: true

must_haves:
  truths:
    - "Query text can be embedded using same model as indexing"
    - "Database can be queried for similar vectors"
    - "Results include file path, byte location, and similarity score"
  artifacts:
    - path: "src/cocosearch/search/__init__.py"
      provides: "Search module exports"
      exports: ["search", "SearchResult", "get_connection_pool"]
    - path: "src/cocosearch/search/db.py"
      provides: "Database connection pool with pgvector"
      exports: ["get_connection_pool", "get_table_name"]
    - path: "src/cocosearch/search/query.py"
      provides: "Core search function"
      exports: ["search", "SearchResult"]
  key_links:
    - from: "src/cocosearch/search/query.py"
      to: "src/cocosearch/indexer/embedder.py"
      via: "code_to_embedding.eval()"
      pattern: "code_to_embedding\\.eval"
    - from: "src/cocosearch/search/query.py"
      to: "src/cocosearch/search/db.py"
      via: "get_connection_pool import"
      pattern: "from.*db.*import.*get_connection_pool"
---

<objective>
Create the search core module with database connectivity and vector similarity search.

Purpose: Establish the foundational search capability that CLI and REPL will build upon.
Output: Working `search()` function that queries PostgreSQL and returns ranked results.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search/03-CONTEXT.md
@.planning/phases/03-search/03-RESEARCH.md
@.planning/phases/02-indexing-pipeline/02-02-SUMMARY.md

# Existing code to understand
@src/cocosearch/indexer/embedder.py
@src/cocosearch/indexer/flow.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create database connection module</name>
  <files>src/cocosearch/search/db.py, src/cocosearch/search/__init__.py</files>
  <action>
Create `src/cocosearch/search/` directory and `db.py` with:

1. **Connection pool singleton:**
```python
from psycopg_pool import ConnectionPool
from pgvector.psycopg import register_vector

_pool: ConnectionPool | None = None

def get_connection_pool() -> ConnectionPool:
    """Get or create the database connection pool."""
    global _pool
    if _pool is None:
        def configure(conn):
            register_vector(conn)
        _pool = ConnectionPool(
            conninfo=os.getenv("COCOINDEX_DATABASE_URL"),
            configure=configure,
        )
    return _pool
```

2. **Table name resolver:**
```python
import cocoindex

def get_table_name(index_name: str) -> str:
    """Get the PostgreSQL table name for an index.

    CocoIndex naming convention: {flow_name}__{target_name}
    Flow name: CodeIndex_{index_name}
    Target name: {index_name}_chunks
    Result: codeindex_{index_name}__{index_name}_chunks
    """
    # CocoIndex lowercases flow names
    flow_name = f"codeindex_{index_name}"
    target_name = f"{index_name}_chunks"
    return f"{flow_name}__{target_name}"
```

Create `src/cocosearch/search/__init__.py` with initial exports (will be extended in Task 2).

**Important:** Do NOT call cocoindex.init() in db.py - that's done at CLI level.
  </action>
  <verify>
```bash
uv run python -c "from cocosearch.search.db import get_connection_pool, get_table_name; print(get_table_name('test'))"
```
Expected output: `codeindex_test__test_chunks`
  </verify>
  <done>Connection pool factory exists and table name derivation matches CocoIndex convention</done>
</task>

<task type="auto">
  <name>Task 2: Create search query function</name>
  <files>src/cocosearch/search/query.py, src/cocosearch/search/__init__.py</files>
  <action>
Create `src/cocosearch/search/query.py` with:

1. **SearchResult dataclass:**
```python
from dataclasses import dataclass

@dataclass
class SearchResult:
    """A single search result."""
    filename: str           # Full file path
    start_byte: int         # Start byte offset
    end_byte: int          # End byte offset
    score: float           # Similarity score (0-1, higher = more similar)
```

2. **Core search function:**
```python
from cocosearch.indexer.embedder import code_to_embedding
from cocosearch.search.db import get_connection_pool, get_table_name

def search(
    query: str,
    index_name: str,
    limit: int = 10,
    min_score: float = 0.0,
    language_filter: str | None = None,
) -> list[SearchResult]:
    """Search for code similar to query.

    Args:
        query: Natural language search query.
        index_name: Name of the index to search.
        limit: Maximum results to return.
        min_score: Minimum similarity score (0-1).
        language_filter: Optional language filter (e.g., "python").

    Returns:
        List of SearchResult ordered by similarity (highest first).
    """
    # Embed query using same model as indexing
    query_embedding = code_to_embedding.eval(query)

    pool = get_connection_pool()
    table_name = get_table_name(index_name)

    # Build query with optional language filter
    # Note: location is stored as int4range [start, end)
    if language_filter:
        extensions = get_extension_patterns(language_filter)
        # Build OR clause for multiple extensions
        ext_conditions = " OR ".join(["filename LIKE %s" for _ in extensions])
        sql = f"""
            SELECT filename, lower(location) as start_byte, upper(location) as end_byte,
                   1 - (embedding <=> %s::vector) AS score
            FROM {table_name}
            WHERE ({ext_conditions})
            ORDER BY embedding <=> %s::vector
            LIMIT %s
        """
        params = [query_embedding] + extensions + [query_embedding, limit]
    else:
        sql = f"""
            SELECT filename, lower(location) as start_byte, upper(location) as end_byte,
                   1 - (embedding <=> %s::vector) AS score
            FROM {table_name}
            ORDER BY embedding <=> %s::vector
            LIMIT %s
        """
        params = [query_embedding, query_embedding, limit]

    with pool.connection() as conn:
        with conn.cursor() as cur:
            cur.execute(sql, params)
            rows = cur.fetchall()

    # Filter by min_score and convert to SearchResult
    results = []
    for row in rows:
        score = float(row[3])
        if score >= min_score:
            results.append(SearchResult(
                filename=row[0],
                start_byte=int(row[1]),
                end_byte=int(row[2]),
                score=score,
            ))

    return results
```

3. **Language extension mapping:**
```python
LANGUAGE_EXTENSIONS = {
    "python": [".py", ".pyw", ".pyi"],
    "javascript": [".js", ".mjs", ".cjs"],
    "typescript": [".ts", ".tsx", ".mts", ".cts"],
    "rust": [".rs"],
    "go": [".go"],
    "java": [".java"],
    "ruby": [".rb"],
    "php": [".php"],
    "c": [".c", ".h"],
    "cpp": [".cpp", ".cc", ".cxx", ".hpp", ".hxx"],
    "csharp": [".cs"],
    "swift": [".swift"],
    "kotlin": [".kt", ".kts"],
    "scala": [".scala"],
    "shell": [".sh", ".bash", ".zsh"],
}

def get_extension_patterns(language: str) -> list[str]:
    """Get SQL LIKE patterns for a language."""
    exts = LANGUAGE_EXTENSIONS.get(language.lower(), [f".{language}"])
    return [f"%{ext}" for ext in exts]
```

4. **Update `__init__.py`:**
Export SearchResult and search from the module.

**Critical pitfalls to avoid (from RESEARCH.md):**
- `<=>` returns distance (0=identical), convert to similarity: `1 - distance`
- `location` is int4range; use `lower(location)` and `upper(location)` in SQL
- Don't create new CocoIndex init - use existing embedder's transform
  </action>
  <verify>
```bash
# Test import and basic function signature
uv run python -c "from cocosearch.search import search, SearchResult; print(SearchResult.__annotations__)"
```

# Full integration test requires running database - defer to plan verification
  </verify>
  <done>search() function implemented with query embedding, vector similarity, and language filtering</done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full search flow:

```bash
# Ensure database is running
docker compose up -d

# Initialize CocoIndex (required before search)
export COCOINDEX_DATABASE_URL="postgresql://cocoindex:cocoindex@localhost:5432/cocoindex"

# Test search on existing index (assumes 02-indexing-pipeline created an index)
uv run python -c "
import cocoindex
cocoindex.init()

from cocosearch.search import search, SearchResult

# This will only work if there's an existing index
# If no index exists, test will show connection works but no results
try:
    results = search('authentication', 'coco_s', limit=3)
    print(f'Found {len(results)} results')
    for r in results:
        print(f'  {r.filename}: {r.score:.3f}')
except Exception as e:
    print(f'Search test: {e}')
"
```
</verification>

<success_criteria>
- [ ] `src/cocosearch/search/db.py` exists with `get_connection_pool()` and `get_table_name()`
- [ ] `src/cocosearch/search/query.py` exists with `search()` and `SearchResult`
- [ ] `search()` uses `code_to_embedding.eval()` for query embedding
- [ ] `search()` uses `1 - (embedding <=> query)` for similarity score
- [ ] `search()` correctly extracts `lower(location)` and `upper(location)` from int4range
- [ ] Language filtering uses LIKE patterns on filename
- [ ] Module imports work: `from cocosearch.search import search, SearchResult`
</success_criteria>

<output>
After completion, create `.planning/phases/03-search/03-01-SUMMARY.md`
</output>
