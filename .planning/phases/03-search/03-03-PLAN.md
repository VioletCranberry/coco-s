---
phase: 03-search
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/cocosearch/search/repl.py
  - src/cocosearch/search/__init__.py
  - src/cocosearch/cli.py

autonomous: true

must_haves:
  truths:
    - "User can enter interactive mode with --interactive flag"
    - "User can type queries and see results without restarting"
    - "User can change settings (limit, lang) during session"
    - "User can exit with quit/exit/Ctrl-D"
  artifacts:
    - path: "src/cocosearch/search/repl.py"
      provides: "Interactive search REPL"
      exports: ["SearchREPL", "run_repl"]
    - path: "src/cocosearch/cli.py"
      provides: "CLI with --interactive flag"
      contains: "--interactive"
  key_links:
    - from: "src/cocosearch/search/repl.py"
      to: "src/cocosearch/search/query.py"
      via: "search() function call"
      pattern: "from.*search.*import.*search"
    - from: "src/cocosearch/search/repl.py"
      to: "src/cocosearch/search/formatter.py"
      via: "format_pretty for display"
      pattern: "from.*formatter.*import.*format_pretty"
---

<objective>
Add interactive REPL mode for continuous search sessions.

Purpose: Enable users to explore code without repeated CLI invocations.
Output: Working `cocosearch --interactive` mode with query loop and settings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-search/03-CONTEXT.md
@.planning/phases/03-search/03-01-SUMMARY.md
@.planning/phases/03-search/03-02-SUMMARY.md

# Existing code to extend
@src/cocosearch/cli.py
@src/cocosearch/search/query.py
@src/cocosearch/search/formatter.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REPL module</name>
  <files>src/cocosearch/search/repl.py, src/cocosearch/search/__init__.py</files>
  <action>
Create `src/cocosearch/search/repl.py` with:

1. **SearchREPL class using cmd module:**
```python
import cmd
import readline  # Enables history/editing
from rich.console import Console

from cocosearch.search import search
from cocosearch.search.formatter import format_pretty
from cocosearch.cli import parse_query_filters


class SearchREPL(cmd.Cmd):
    """Interactive search REPL.

    Commands:
        <query>     - Search for query
        :limit N    - Set result limit
        :lang X     - Set language filter (empty to clear)
        :context N  - Set context lines
        :index X    - Switch index
        :help       - Show help
        quit/exit   - Exit REPL
    """

    intro = None  # Set in __init__ for Rich formatting
    prompt = "cocosearch> "

    def __init__(
        self,
        index_name: str,
        limit: int = 10,
        context_lines: int = 5,
        min_score: float = 0.3,
    ):
        super().__init__()
        self.console = Console()
        self.index_name = index_name
        self.limit = limit
        self.context_lines = context_lines
        self.min_score = min_score
        self.lang_filter: str | None = None

        # Show intro with Rich
        self.console.print("[bold]CocoSearch Interactive Mode[/bold]")
        self.console.print(f"[dim]Index: {index_name} | Limit: {limit} | Context: {context_lines} lines[/dim]")
        self.console.print("[dim]Type :help for commands, quit to exit[/dim]\n")

    def default(self, line: str) -> bool:
        """Handle search queries (default action)."""
        if not line.strip():
            return False

        # Check for settings commands
        if line.startswith(":"):
            return self.handle_setting(line)

        # Parse inline filters
        query, inline_lang = parse_query_filters(line)
        lang = inline_lang or self.lang_filter

        try:
            results = search(
                query=query,
                index_name=self.index_name,
                limit=self.limit,
                min_score=self.min_score,
                language_filter=lang,
            )
            format_pretty(results, context_lines=self.context_lines, console=self.console)
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")

        return False

    def handle_setting(self, line: str) -> bool:
        """Handle :setting commands."""
        parts = line[1:].split(maxsplit=1)
        cmd_name = parts[0].lower()
        value = parts[1] if len(parts) > 1 else ""

        if cmd_name == "limit":
            try:
                self.limit = int(value)
                self.console.print(f"[dim]Limit set to {self.limit}[/dim]")
            except ValueError:
                self.console.print("[red]Usage: :limit N[/red]")

        elif cmd_name == "lang":
            if value:
                self.lang_filter = value
                self.console.print(f"[dim]Language filter: {self.lang_filter}[/dim]")
            else:
                self.lang_filter = None
                self.console.print("[dim]Language filter cleared[/dim]")

        elif cmd_name == "context":
            try:
                self.context_lines = int(value)
                self.console.print(f"[dim]Context lines set to {self.context_lines}[/dim]")
            except ValueError:
                self.console.print("[red]Usage: :context N[/red]")

        elif cmd_name == "index":
            if value:
                self.index_name = value
                self.console.print(f"[dim]Switched to index: {self.index_name}[/dim]")
            else:
                self.console.print("[red]Usage: :index NAME[/red]")

        elif cmd_name == "help":
            self.do_help("")

        else:
            self.console.print(f"[red]Unknown command: :{cmd_name}[/red]")

        return False

    def do_help(self, arg: str) -> bool:
        """Show help message."""
        self.console.print("""
[bold]Commands:[/bold]
  <query>       Search for code matching query
  :limit N      Set max results (current: {limit})
  :lang X       Set language filter (current: {lang})
  :context N    Set context lines (current: {context})
  :index X      Switch to different index
  :help         Show this help
  quit, exit    Exit interactive mode

[bold]Tips:[/bold]
  - Use lang:python in query for inline filtering
  - Press Up/Down for command history
  - Press Ctrl-D to exit
""".format(
            limit=self.limit,
            lang=self.lang_filter or "none",
            context=self.context_lines,
        ))
        return False

    def do_quit(self, arg: str) -> bool:
        """Exit the REPL."""
        self.console.print("[dim]Goodbye![/dim]")
        return True

    def do_exit(self, arg: str) -> bool:
        """Exit the REPL."""
        return self.do_quit(arg)

    def do_EOF(self, arg: str) -> bool:
        """Handle Ctrl-D."""
        self.console.print()  # Newline after ^D
        return self.do_quit(arg)

    def emptyline(self) -> bool:
        """Do nothing on empty line (don't repeat last command)."""
        return False


def run_repl(
    index_name: str,
    limit: int = 10,
    context_lines: int = 5,
    min_score: float = 0.3,
) -> None:
    """Run the interactive search REPL.

    Args:
        index_name: Name of the index to search.
        limit: Initial result limit.
        context_lines: Initial context lines.
        min_score: Minimum score threshold.
    """
    repl = SearchREPL(
        index_name=index_name,
        limit=limit,
        context_lines=context_lines,
        min_score=min_score,
    )
    try:
        repl.cmdloop()
    except KeyboardInterrupt:
        repl.console.print("\n[dim]Interrupted. Goodbye![/dim]")
```

Update `__init__.py` to export `run_repl`.
  </action>
  <verify>
```bash
# Test module import
uv run python -c "from cocosearch.search.repl import SearchREPL, run_repl; print('REPL module loaded')"

# Test REPL class instantiation
uv run python -c "
from cocosearch.search.repl import SearchREPL
repl = SearchREPL('test_index')
print(f'REPL prompt: {repl.prompt}')
print(f'REPL limit: {repl.limit}')
"
  </verify>
  <done>REPL module created with SearchREPL class, settings commands, and history support</done>
</task>

<task type="auto">
  <name>Task 2: Add --interactive flag to CLI</name>
  <files>src/cocosearch/cli.py</files>
  <action>
Update `src/cocosearch/cli.py` to add interactive mode:

1. **Add --interactive flag to search parser:**
```python
search_parser.add_argument(
    "-i", "--interactive",
    action="store_true",
    help="Enter interactive search mode",
)
```

2. **Update search_command to handle interactive mode:**
```python
from cocosearch.search.repl import run_repl

def search_command(args: argparse.Namespace) -> int:
    """Execute the search command."""
    console = Console()

    # Initialize CocoIndex
    cocoindex.init()

    # Determine index name
    if args.index:
        index_name = args.index
    else:
        index_name = derive_index_name(os.getcwd())

    # Handle interactive mode
    if args.interactive:
        run_repl(
            index_name=index_name,
            limit=args.limit,
            context_lines=args.context,
            min_score=args.min_score,
        )
        return 0

    # Require query for non-interactive mode
    if not hasattr(args, 'query') or not args.query:
        console.print("[bold red]Error:[/bold red] Query required (use --interactive for REPL mode)")
        return 1

    # ... rest of existing search_command code ...
```

3. **Make query optional when --interactive is used:**
Modify the search_parser to make query optional:

```python
search_parser.add_argument(
    "query",
    nargs="?",  # Make optional
    default=None,
    help="Natural language search query (not needed with --interactive)",
)
```

4. **Update default action handling to support --interactive:**
In main(), when checking for default action, also handle `--interactive`:

```python
if args.command is None:
    if len(sys.argv) > 1:
        first_arg = sys.argv[1]
        if first_arg not in ["index", "search", "-h", "--help"]:
            # Could be a query OR a flag like --interactive
            sys.argv.insert(1, "search")
            args = parser.parse_args()
```
  </action>
  <verify>
```bash
# Test --interactive flag shows in help
uv run cocosearch search --help | grep interactive

# Test interactive flag (will start REPL, immediately send quit)
echo "quit" | uv run cocosearch --interactive --index test 2>&1 | head -10
  </verify>
  <done>CLI extended with --interactive flag that launches REPL mode</done>
</task>

</tasks>

<verification>
After all tasks complete, verify full REPL functionality:

```bash
# Ensure infrastructure is running
docker compose up -d

export COCOINDEX_DATABASE_URL="postgresql://cocoindex:cocoindex@localhost:5432/cocoindex"

# Test REPL with automated input
echo -e ":help\n:limit 5\nconfig\nquit" | uv run cocosearch --interactive --index coco_s

# Verify exit codes
uv run cocosearch --interactive --index test <<< "quit" && echo "Exit code: $?"
```
</verification>

<success_criteria>
- [ ] `cocosearch --interactive` enters REPL mode
- [ ] REPL shows prompt `cocosearch> `
- [ ] Typing a query executes search with pretty output
- [ ] `:limit N` changes result limit
- [ ] `:lang python` sets language filter
- [ ] `:context N` changes context lines
- [ ] `:index name` switches index
- [ ] `:help` shows available commands
- [ ] `quit` and `exit` exit REPL
- [ ] Ctrl-D exits REPL
- [ ] Up/Down arrows navigate command history
</success_criteria>

<output>
After completion, create `.planning/phases/03-search/03-03-SUMMARY.md`
</output>
