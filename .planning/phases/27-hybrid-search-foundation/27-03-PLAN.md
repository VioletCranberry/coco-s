---
phase: 27-hybrid-search-foundation
plan: 03
type: execute
wave: 3
depends_on: ["27-01", "27-02"]
files_modified:
  - src/cocosearch/indexer/tsvector.py
  - src/cocosearch/indexer/flow.py
  - tests/unit/test_tsvector.py
  - tests/integration/test_hybrid_schema.py
autonomous: true

must_haves:
  truths:
    - "PostgreSQL tsvector is generated from content_text during indexing"
    - "GIN index is created on content_tsv column for search performance"
    - "New indexes have content_text and content_tsv columns"
    - "tsvector generation handles code identifiers (camelCase, snake_case splitting)"
  artifacts:
    - path: "src/cocosearch/indexer/tsvector.py"
      provides: "tsvector generation for code content"
      contains: "to_tsvector"
    - path: "src/cocosearch/indexer/flow.py"
      provides: "Flow with content_tsv column"
      contains: "content_tsv"
    - path: "tests/unit/test_tsvector.py"
      provides: "Unit tests for tsvector generation"
      contains: "test_"
    - path: "tests/integration/test_hybrid_schema.py"
      provides: "Integration tests verifying schema with hybrid columns"
      contains: "content_tsv"
  key_links:
    - from: "src/cocosearch/indexer/flow.py"
      to: "src/cocosearch/indexer/tsvector.py"
      via: "text_to_tsvector transform"
      pattern: "text_to_tsvector"
---

<objective>
Add tsvector generation for PostgreSQL full-text search and GIN index creation.

Purpose: Complete the hybrid search infrastructure (HYBR-05, HYBR-06) by adding content_tsv column with GIN index, enabling fast keyword searches in Phase 28. The tsvector generation includes code-aware tokenization (splitting camelCase, snake_case).

Output: New tsvector.py module, updated flow.py with content_tsv, GIN index configuration, unit and integration tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/research/ARCHITECTURE_SEARCH_ENHANCEMENTS.md
@.planning/research/PITFALLS-search-enhancements.md

@src/cocosearch/indexer/flow.py
@src/cocosearch/search/query.py

# Reference: Plan 01 added content_text field
# Reference: Plan 02 added graceful degradation
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tsvector generation module</name>
  <files>src/cocosearch/indexer/tsvector.py</files>
  <action>
Create a new module for generating PostgreSQL tsvector from code content.

Key considerations from PITFALLS research (Pitfall 2: Tokenization Preprocessing Inconsistency, Pitfall 12: BM25 Query Expansion for Code Identifiers):
- Split camelCase and snake_case identifiers into separate tokens
- Preserve original identifiers as well (for exact match)
- Use PostgreSQL's to_tsvector with 'simple' config (no stemming) for code

```python
"""tsvector generation for hybrid search.

Converts code content to PostgreSQL tsvector format for full-text search.
Includes code-aware tokenization that handles:
- camelCase splitting: getUserById -> get user by id
- snake_case splitting: get_user_by_id -> get user by id
- Original identifiers preserved for exact match

Uses PostgreSQL 'simple' text search config (no stemming) because:
- Code identifiers shouldn't be stemmed (running != run in code)
- Case is preserved in original but lowercased tokens also added
"""

import re


def split_code_identifier(identifier: str) -> list[str]:
    """Split a code identifier into searchable tokens.

    Handles camelCase, PascalCase, snake_case, and kebab-case.

    Args:
        identifier: Code identifier (e.g., "getUserById", "get_user_by_id")

    Returns:
        List of tokens including original and split parts.

    Examples:
        >>> split_code_identifier("getUserById")
        ['getUserById', 'get', 'User', 'By', 'Id']
        >>> split_code_identifier("get_user_by_id")
        ['get_user_by_id', 'get', 'user', 'by', 'id']
    """
    tokens = [identifier]  # Always include original

    # Split camelCase/PascalCase
    camel_parts = re.findall(r'[A-Z]?[a-z]+|[A-Z]+(?=[A-Z][a-z]|\d|\W|$)|\d+', identifier)
    if camel_parts and len(camel_parts) > 1:
        tokens.extend(camel_parts)

    # Split snake_case/kebab-case
    if '_' in identifier or '-' in identifier:
        snake_parts = re.split(r'[_-]', identifier)
        snake_parts = [p for p in snake_parts if p]
        if len(snake_parts) > 1:
            tokens.extend(snake_parts)

    return tokens


def preprocess_code_for_tsvector(content: str) -> str:
    """Preprocess code content for tsvector generation.

    Extracts identifiers and splits them for better keyword matching.
    The result is a space-separated string suitable for to_tsvector().

    Args:
        content: Raw code content (chunk text)

    Returns:
        Preprocessed text with split identifiers, ready for to_tsvector().
    """
    # Extract potential identifiers (alphanumeric sequences with underscores)
    # This pattern matches: variable_name, functionName, ClassName, etc.
    identifier_pattern = r'\b[a-zA-Z_][a-zA-Z0-9_]*\b'
    identifiers = re.findall(identifier_pattern, content)

    # Split each identifier and collect all tokens
    all_tokens = []
    for ident in identifiers:
        if len(ident) >= 2:  # Skip single-char identifiers
            tokens = split_code_identifier(ident)
            all_tokens.extend(tokens)

    # Also include raw words for natural language in comments
    # (to_tsvector will handle deduplication)
    words = re.findall(r'\b\w+\b', content.lower())
    all_tokens.extend(words)

    # Join with spaces for to_tsvector input
    return ' '.join(all_tokens)


def text_to_tsvector_sql(content: str) -> str:
    """Generate SQL expression for creating tsvector from content.

    Returns the preprocessed text that should be passed to PostgreSQL's
    to_tsvector('simple', ...) function.

    Note: The actual to_tsvector() call happens in PostgreSQL, not Python.
    This function prepares the input text.

    Args:
        content: Raw code content (chunk text)

    Returns:
        Preprocessed text ready for to_tsvector('simple', ...)
    """
    return preprocess_code_for_tsvector(content)
```

This module provides the preprocessing step. The actual tsvector column will be a PostgreSQL generated column or populated during indexing.
  </action>
  <verify>
Read src/cocosearch/indexer/tsvector.py and verify:
1. split_code_identifier handles camelCase, snake_case
2. preprocess_code_for_tsvector extracts and processes identifiers
3. Docstrings explain the approach
4. No external dependencies (uses only re from stdlib)
  </verify>
  <done>
tsvector generation module handles code-aware tokenization for keyword search.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add content_tsv to indexing flow</name>
  <files>src/cocosearch/indexer/flow.py</files>
  <action>
Update the indexing flow to generate and store content_tsv alongside content_text.

Read the current flow.py (which now has content_text from Plan 01).

Add import for tsvector module:
```python
from cocosearch.indexer.tsvector import text_to_tsvector_sql
```

Update the chunk processing to include content_tsv:
```python
# Step 4: Process each chunk
with file["chunks"].row() as chunk:
    # Generate embedding via Ollama using shared transform
    chunk["embedding"] = chunk["text"].call(code_to_embedding)

    # Extract DevOps metadata (block_type, hierarchy, language_id)
    chunk["metadata"] = chunk["text"].transform(
        extract_devops_metadata,
        language=file["extension"],
    )

    # v1.7 Hybrid Search: Store chunk text and tsvector for keyword search
    # content_text: Raw text for storage and potential future use
    # content_tsv: Preprocessed text for PostgreSQL to_tsvector()
    chunk["content_tsv_input"] = chunk["text"].transform(text_to_tsvector_sql)

    # Collect with metadata (includes hybrid search columns)
    code_embeddings.collect(
        filename=file["filename"],
        location=chunk["location"],
        embedding=chunk["embedding"],
        content_text=chunk["text"],  # Raw text for hybrid search
        content_tsv_input=chunk["content_tsv_input"],  # Preprocessed for tsvector
        block_type=chunk["metadata"]["block_type"],
        hierarchy=chunk["metadata"]["hierarchy"],
        language_id=chunk["metadata"]["language_id"],
    )
```

Note: CocoIndex will create a TEXT column for content_tsv_input. The actual tsvector column and GIN index need to be created via PostgreSQL migration or post-processing. This is a limitation of CocoIndex which doesn't support native tsvector types.

Alternative approach (if CocoIndex supports custom SQL): Use a PostgreSQL generated column:
```sql
-- This would be ideal, but depends on CocoIndex support
ALTER TABLE ... ADD COLUMN content_tsv TSVECTOR
    GENERATED ALWAYS AS (to_tsvector('simple', content_tsv_input)) STORED;
CREATE INDEX idx_content_tsv ON ... USING GIN (content_tsv);
```

For now, store the preprocessed text. The GIN index creation will be handled separately.
  </action>
  <verify>
Read src/cocosearch/indexer/flow.py and verify:
1. text_to_tsvector_sql imported from tsvector module
2. chunk["content_tsv_input"] transform added
3. content_tsv_input included in code_embeddings.collect()
4. Comments explain hybrid search purpose
  </verify>
  <done>
Indexing flow generates preprocessed text for tsvector keyword search.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for tsvector module</name>
  <files>tests/unit/test_tsvector.py</files>
  <action>
Create unit tests for the tsvector generation module.

```python
"""Unit tests for tsvector generation module."""

import pytest

from cocosearch.indexer.tsvector import (
    split_code_identifier,
    preprocess_code_for_tsvector,
    text_to_tsvector_sql,
)


class TestSplitCodeIdentifier:
    """Tests for split_code_identifier function."""

    def test_camel_case_splitting(self):
        """Test camelCase identifier splitting."""
        result = split_code_identifier("getUserById")
        assert "getUserById" in result  # Original preserved
        assert "get" in result
        assert "User" in result
        assert "By" in result
        assert "Id" in result

    def test_pascal_case_splitting(self):
        """Test PascalCase identifier splitting."""
        result = split_code_identifier("UserRepository")
        assert "UserRepository" in result
        assert "User" in result
        assert "Repository" in result

    def test_snake_case_splitting(self):
        """Test snake_case identifier splitting."""
        result = split_code_identifier("get_user_by_id")
        assert "get_user_by_id" in result
        assert "get" in result
        assert "user" in result
        assert "by" in result
        assert "id" in result

    def test_kebab_case_splitting(self):
        """Test kebab-case identifier splitting."""
        result = split_code_identifier("get-user-by-id")
        assert "get-user-by-id" in result
        assert "get" in result
        assert "user" in result

    def test_simple_identifier_preserved(self):
        """Test that simple identifiers are preserved."""
        result = split_code_identifier("user")
        assert "user" in result

    def test_mixed_case_with_numbers(self):
        """Test identifiers with numbers."""
        result = split_code_identifier("user2")
        assert "user2" in result

    def test_uppercase_acronym(self):
        """Test identifiers with uppercase acronyms."""
        result = split_code_identifier("parseHTTPRequest")
        assert "parseHTTPRequest" in result
        assert "parse" in result
        assert "HTTP" in result or "Request" in result


class TestPreprocessCodeForTsvector:
    """Tests for preprocess_code_for_tsvector function."""

    def test_extracts_function_definition(self):
        """Test extraction from function definition."""
        code = "def getUserById(user_id):\n    return db.query(user_id)"
        result = preprocess_code_for_tsvector(code)

        # Should contain split tokens
        assert "get" in result.lower()
        assert "user" in result.lower()

    def test_includes_comments(self):
        """Test that comment text is included."""
        code = "# This function retrieves a user from the database\ndef get_user():"
        result = preprocess_code_for_tsvector(code)

        # Comment words should be present
        assert "retrieves" in result.lower() or "user" in result.lower()

    def test_handles_empty_string(self):
        """Test handling of empty input."""
        result = preprocess_code_for_tsvector("")
        assert result == "" or result.strip() == ""

    def test_handles_symbols_only(self):
        """Test handling of code with only symbols."""
        code = "{ } ( ) [ ] ; : , ."
        result = preprocess_code_for_tsvector(code)
        # Should handle gracefully, may be empty or have minimal tokens
        assert isinstance(result, str)


class TestTextToTsvectorSql:
    """Tests for text_to_tsvector_sql function."""

    def test_returns_preprocessed_string(self):
        """Test that function returns a string suitable for to_tsvector."""
        code = "def hello_world():\n    print('Hello')"
        result = text_to_tsvector_sql(code)

        assert isinstance(result, str)
        assert len(result) > 0
        # Should contain searchable tokens
        assert "hello" in result.lower() or "world" in result.lower()
```
  </action>
  <verify>
Run: `cd /Users/fedorzhdanov/GIT/personal/coco-s && uv run pytest tests/unit/test_tsvector.py -v --tb=short`

All tests should pass.
  </verify>
  <done>
Unit tests verify tsvector generation handles code identifiers correctly.
  </done>
</task>

</tasks>

<verification>
1. Read src/cocosearch/indexer/tsvector.py and verify module structure
2. Read src/cocosearch/indexer/flow.py and verify content_tsv_input field
3. Run tsvector unit tests: `uv run pytest tests/unit/test_tsvector.py -v --tb=short`
4. Run all unit tests: `uv run pytest tests/unit/ -v --tb=short`
</verification>

<success_criteria>
- [x] tsvector.py module created with code-aware tokenization
- [x] split_code_identifier handles camelCase, snake_case, PascalCase
- [x] preprocess_code_for_tsvector extracts and processes identifiers
- [x] flow.py updated with content_tsv_input field
- [x] Unit tests for tsvector module pass
- [x] All existing unit tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/27-hybrid-search-foundation/27-03-SUMMARY.md`
</output>
