---
phase: 09-metadata-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/indexer/metadata.py
  - src/cocosearch/indexer/__init__.py
  - tests/indexer/test_metadata.py
autonomous: true

must_haves:
  truths:
    - "HCL chunk starting with 'resource \"aws_s3_bucket\" \"data\"' produces block_type=resource, hierarchy=resource.aws_s3_bucket.data, language_id=hcl"
    - "Dockerfile chunk starting with 'FROM golang:1.21 AS builder' produces block_type=FROM, hierarchy=stage:builder, language_id=dockerfile"
    - "Bash chunk starting with 'deploy_app() {' produces block_type=function, hierarchy=function:deploy_app, language_id=bash"
    - "Python file chunk produces block_type='', hierarchy='', language_id='' (empty strings, not NULLs)"
    - "Comment lines containing block keywords like '# This resource was replaced' do not produce false-positive metadata"
    - "extract_devops_metadata is decorated with @cocoindex.op.function() and returns DevOpsMetadata dataclass"
    - "All regex patterns are compiled at module level (not inside functions)"
  artifacts:
    - path: "src/cocosearch/indexer/metadata.py"
      provides: "DevOpsMetadata dataclass, per-language extractors, dispatch function"
      exports: ["DevOpsMetadata", "extract_devops_metadata", "extract_hcl_metadata", "extract_dockerfile_metadata", "extract_bash_metadata"]
    - path: "tests/indexer/test_metadata.py"
      provides: "Comprehensive unit tests for all extraction functions"
      min_lines: 150
    - path: "src/cocosearch/indexer/__init__.py"
      provides: "Updated module exports including metadata symbols"
      contains: "DevOpsMetadata"
  key_links:
    - from: "src/cocosearch/indexer/metadata.py"
      to: "cocoindex.op.function"
      via: "decorator on extract_devops_metadata"
      pattern: "@cocoindex\\.op\\.function"
    - from: "src/cocosearch/indexer/metadata.py"
      to: "dataclasses.dataclass"
      via: "DevOpsMetadata class definition"
      pattern: "@dataclasses\\.dataclass"
    - from: "tests/indexer/test_metadata.py"
      to: "src/cocosearch/indexer/metadata.py"
      via: "imports of extraction functions and DevOpsMetadata"
      pattern: "from cocosearch\\.indexer\\.metadata import"
---

<objective>
Create the standalone metadata extraction module that extracts structured DevOps metadata from chunk text using regex.

Purpose: Every DevOps chunk needs structured metadata (block_type, hierarchy, language_id) so that Phase 3 can wire it into the flow and Phase 4 can surface it in search results. This module is the core extraction logic.

Output: `metadata.py` with DevOpsMetadata dataclass, per-language extractors (HCL, Dockerfile, Bash), a CocoIndex op function dispatcher, and comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-metadata-extraction/09-RESEARCH.md
@.planning/phases/09-metadata-extraction/09-CONTEXT.md
@src/cocosearch/indexer/embedder.py
@src/cocosearch/indexer/languages.py
@src/cocosearch/indexer/__init__.py
@tests/indexer/test_languages.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metadata.py with DevOpsMetadata dataclass and extraction functions</name>
  <files>src/cocosearch/indexer/metadata.py</files>
  <action>
Create `src/cocosearch/indexer/metadata.py` with the following structure. Follow the existing code style in `embedder.py` and `languages.py` (module docstring, imports at top, constants, then functions).

**Module docstring:** Explain this module extracts structured metadata from DevOps file chunks using regex.

**Imports:**
```python
import dataclasses
import re

import cocoindex
```

**1. DevOpsMetadata dataclass:**
```python
@dataclasses.dataclass
class DevOpsMetadata:
    """Structured metadata for a DevOps file chunk."""
    block_type: str   # e.g., "resource", "FROM", "function", or ""
    hierarchy: str    # e.g., "resource.aws_s3_bucket.data", "stage:builder", or ""
    language_id: str  # "hcl", "dockerfile", "bash", or ""
```

**2. Module-level compiled regex patterns (CRITICAL: compile at module level, not inside functions):**

Comment patterns:
- `_HCL_COMMENT_LINE`: `r'^\s*(?:#|//|/\*).*$'` (re.MULTILINE) -- matches HCL comment lines
- `_DOCKERFILE_COMMENT_LINE`: `r'^\s*#.*$'` (re.MULTILINE) -- matches Dockerfile comment lines
- `_BASH_COMMENT_LINE`: `r'^\s*#.*$'` (re.MULTILINE) -- matches Bash comment lines

Block extraction patterns:
- `_HCL_BLOCK_RE`: Match the 12 HCL block keywords at line start, optionally followed by 1-2 quoted labels, then optional opening brace:
  ```python
  _HCL_BLOCK_RE = re.compile(
      r'^(resource|data|variable|output|locals|module|provider|terraform|import|moved|removed|check)'
      r'(?:\s+"([^"]*)")?'   # optional first label
      r'(?:\s+"([^"]*)")?'   # optional second label
      r'\s*\{?',
  )
  ```
- `_DOCKERFILE_INSTRUCTION_RE`: Match any of the 18 Dockerfile instructions at line start:
  ```python
  _DOCKERFILE_INSTRUCTION_RE = re.compile(
      r'^(FROM|RUN|CMD|LABEL|MAINTAINER|EXPOSE|ENV|ADD|COPY|ENTRYPOINT|'
      r'VOLUME|USER|WORKDIR|ARG|ONBUILD|STOPSIGNAL|HEALTHCHECK|SHELL)\b'
  )
  ```
- `_DOCKERFILE_FROM_RE`: Match FROM with optional --platform and optional AS clause:
  ```python
  _DOCKERFILE_FROM_RE = re.compile(
      r'^FROM\s+'
      r'(?:--platform=\S+\s+)?'
      r'(\S+)'                    # image reference
      r'(?:\s+[Aa][Ss]\s+(\S+))?'  # optional AS stage_name (case-insensitive AS)
  )
  ```
- `_BASH_FUNCTION_RE`: Match all 3 Bash function syntaxes:
  ```python
  _BASH_FUNCTION_RE = re.compile(
      r'^(?:'
      r'function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(\s*\))?\s*\{?'
      r'|'
      r'([a-zA-Z_][a-zA-Z0-9_]*)\s*\(\s*\)\s*\{?'
      r')'
  )
  ```

**3. Helper function `_strip_leading_comments(text, comment_pattern)`:**
- Takes chunk text and a compiled comment pattern
- Strips leading whitespace from text using `lstrip()`
- Splits into lines
- Iterates lines, skipping blank lines and lines matching the comment pattern
- Returns the remaining text from the first non-comment, non-blank line onward
- Returns empty string if all lines are comments/blank

**4. Per-language extraction functions (plain Python, NOT decorated):**

`extract_hcl_metadata(text: str) -> DevOpsMetadata`:
- Strip leading comments using `_strip_leading_comments(text, _HCL_COMMENT_LINE)`
- Apply `_HCL_BLOCK_RE.match()` on the stripped text
- If match: block_type = group(1), build hierarchy from block_type + optional labels (dot-separated)
  - 0 labels: hierarchy = block_type (e.g., "terraform", "locals")
  - 1 label: hierarchy = f"{block_type}.{label1}" (e.g., "module.vpc")
  - 2 labels: hierarchy = f"{block_type}.{label1}.{label2}" (e.g., "resource.aws_s3_bucket.data")
- If no match: return DevOpsMetadata(block_type="", hierarchy="", language_id="hcl")
- Always set language_id="hcl"

`extract_dockerfile_metadata(text: str) -> DevOpsMetadata`:
- Strip leading comments using `_strip_leading_comments(text, _DOCKERFILE_COMMENT_LINE)`
- Apply `_DOCKERFILE_INSTRUCTION_RE.match()` on the stripped text
- If match and instruction is FROM: apply `_DOCKERFILE_FROM_RE.match()` to extract stage name or image
  - If AS clause present: hierarchy = f"stage:{stage_name}"
  - If no AS clause: hierarchy = f"image:{image_ref}"
- If match and instruction is NOT FROM: hierarchy = "" (non-FROM instructions get empty hierarchy in v1.2, per REQ-10)
- If no match: return DevOpsMetadata(block_type="", hierarchy="", language_id="dockerfile")
- Always set language_id="dockerfile"

`extract_bash_metadata(text: str) -> DevOpsMetadata`:
- Strip leading comments using `_strip_leading_comments(text, _BASH_COMMENT_LINE)`
- Apply `_BASH_FUNCTION_RE.match()` on the stripped text
- If match: block_type = "function", extract function name from group(1) or group(2) (whichever is not None), hierarchy = f"function:{func_name}"
- If no match: return DevOpsMetadata(block_type="", hierarchy="", language_id="bash")
- Always set language_id="bash"

**5. Dispatch maps and main function:**

```python
_LANGUAGE_DISPATCH = {
    "hcl": extract_hcl_metadata,
    "tf": extract_hcl_metadata,
    "tfvars": extract_hcl_metadata,
    "dockerfile": extract_dockerfile_metadata,
    "sh": extract_bash_metadata,
    "bash": extract_bash_metadata,
    "zsh": extract_bash_metadata,
    "shell": extract_bash_metadata,
}

_LANGUAGE_ID_MAP = {
    "hcl": "hcl", "tf": "hcl", "tfvars": "hcl",
    "dockerfile": "dockerfile",
    "sh": "bash", "bash": "bash", "zsh": "bash", "shell": "bash",
}

_EMPTY_METADATA = DevOpsMetadata(block_type="", hierarchy="", language_id="")
```

```python
@cocoindex.op.function()
def extract_devops_metadata(text: str, language: str) -> DevOpsMetadata:
    """Extract structured metadata from a DevOps file chunk.

    Args:
        text: The chunk text content.
        language: Language identifier from extract_language() (e.g., "tf", "dockerfile", "sh").

    Returns:
        DevOpsMetadata with extracted fields, or empty strings for non-DevOps files.
    """
    extractor = _LANGUAGE_DISPATCH.get(language)
    if extractor is None:
        return _EMPTY_METADATA

    metadata = extractor(text)
    # Override language_id with canonical ID (e.g., "tf" -> "hcl")
    return DevOpsMetadata(
        block_type=metadata.block_type,
        hierarchy=metadata.hierarchy,
        language_id=_LANGUAGE_ID_MAP[language],
    )
```

**Important implementation notes:**
- Do NOT import anything from `languages.py` -- metadata.py is standalone
- Do NOT import `extract_language` from embedder.py -- the language string is passed as a parameter
- Use `re.match()` (not `re.search()`) for block patterns -- we only want to match at the START of the text
- The per-language extractors set language_id to the canonical form (e.g., "hcl"), but the dispatch function overrides it using `_LANGUAGE_ID_MAP` to ensure consistency. This means the per-language extractors can hardcode their own language_id for standalone use.
  </action>
  <verify>
Run: `cd /Users/fzhdanov/GIT/personal/coco-s && python -c "from cocosearch.indexer.metadata import DevOpsMetadata, extract_hcl_metadata, extract_dockerfile_metadata, extract_bash_metadata; print('imports OK')"`
Verify output is "imports OK" with no import errors.

Run: `cd /Users/fzhdanov/GIT/personal/coco-s && python -c "
from cocosearch.indexer.metadata import extract_hcl_metadata, extract_dockerfile_metadata, extract_bash_metadata
h = extract_hcl_metadata('resource \"aws_s3_bucket\" \"data\" {')
assert h.block_type == 'resource' and h.hierarchy == 'resource.aws_s3_bucket.data', f'HCL failed: {h}'
d = extract_dockerfile_metadata('FROM golang:1.21 AS builder')
assert d.block_type == 'FROM' and d.hierarchy == 'stage:builder', f'Docker failed: {d}'
b = extract_bash_metadata('deploy_app() {')
assert b.block_type == 'function' and b.hierarchy == 'function:deploy_app', f'Bash failed: {b}'
print('smoke tests OK')
"`
Verify output is "smoke tests OK".
  </verify>
  <done>
metadata.py exists with DevOpsMetadata dataclass, module-level compiled regex patterns, comment stripping helper, 3 per-language extraction functions, dispatch maps, and @cocoindex.op.function() decorated extract_devops_metadata. All regex compiled at module level. Smoke tests pass for roadmap success criteria examples.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_metadata.py and update __init__.py exports</name>
  <files>tests/indexer/test_metadata.py, src/cocosearch/indexer/__init__.py</files>
  <action>
**Part A: Create `tests/indexer/test_metadata.py`**

Follow the existing test style from `tests/indexer/test_languages.py` and `tests/indexer/test_config.py` (class-based grouping, descriptive method names with docstrings, direct imports from the module).

Import the per-language functions and DevOpsMetadata directly -- do NOT import `extract_devops_metadata` (it has the `@cocoindex.op.function()` decorator which may require CocoIndex runtime). Test the internal functions which are pure Python.

```python
from cocosearch.indexer.metadata import (
    DevOpsMetadata,
    extract_hcl_metadata,
    extract_dockerfile_metadata,
    extract_bash_metadata,
    _strip_leading_comments,
    _HCL_COMMENT_LINE,
    _DOCKERFILE_COMMENT_LINE,
    _BASH_COMMENT_LINE,
    _LANGUAGE_DISPATCH,
    _LANGUAGE_ID_MAP,
    _EMPTY_METADATA,
)
```

**Test classes:**

`TestDevOpsMetadata`:
- `test_dataclass_fields`: DevOpsMetadata has exactly 3 fields: block_type, hierarchy, language_id
- `test_empty_metadata_constant`: `_EMPTY_METADATA` has all empty strings

`TestStripLeadingComments`:
- `test_strips_hash_comments`: Text starting with `# comment\nresource` returns text from `resource` onward
- `test_strips_blank_lines`: Text starting with `\n\n\nresource` returns text from `resource` onward
- `test_preserves_non_comment_text`: Text starting with `resource` is returned unchanged (after lstrip)
- `test_all_comments_returns_empty`: Text with only comments returns empty string
- `test_strips_leading_whitespace`: Text starting with `   \n# comment\nresource` handles leading whitespace

`TestExtractHclMetadata`:
- `test_resource_two_labels`: `resource "aws_s3_bucket" "data" {` produces block_type="resource", hierarchy="resource.aws_s3_bucket.data", language_id="hcl"
- `test_data_two_labels`: `data "aws_iam_policy" "admin" {` produces block_type="data", hierarchy="data.aws_iam_policy.admin"
- `test_module_one_label`: `module "vpc" {` produces block_type="module", hierarchy="module.vpc"
- `test_variable_one_label`: `variable "name" {` produces block_type="variable", hierarchy="variable.name"
- `test_output_one_label`: `output "id" {` produces block_type="output", hierarchy="output.id"
- `test_provider_one_label`: `provider "aws" {` produces block_type="provider", hierarchy="provider.aws"
- `test_check_one_label`: `check "health" {` produces block_type="check", hierarchy="check.health"
- `test_terraform_no_labels`: `terraform {` produces block_type="terraform", hierarchy="terraform"
- `test_locals_no_labels`: `locals {` produces block_type="locals", hierarchy="locals"
- `test_import_no_labels`: `import {` produces block_type="import", hierarchy="import"
- `test_moved_no_labels`: `moved {` produces block_type="moved", hierarchy="moved"
- `test_removed_no_labels`: `removed {` produces block_type="removed", hierarchy="removed"
- `test_comment_before_block`: `# This resource\nresource "aws_s3_bucket" "data" {` produces block_type="resource" (comment correctly skipped)
- `test_comment_with_keyword_no_block`: `# This resource was replaced\nsome_other_content` produces block_type="" (comment keyword is not a false positive)
- `test_leading_newline`: `\nresource "aws_s3_bucket" "data" {` handles leading whitespace from separator
- `test_unrecognized_content`: `unknown_block {` produces block_type="", hierarchy="", language_id="hcl"
- `test_hcl_inline_comment`: `// resource declaration\nresource "type" "name" {` skips `//` comment
- `test_hcl_block_comment`: `/* block comment */\nresource "type" "name" {` skips `/* */` comment

`TestExtractDockerfileMetadata`:
- `test_from_with_as`: `FROM golang:1.21 AS builder` produces block_type="FROM", hierarchy="stage:builder", language_id="dockerfile"
- `test_from_without_as`: `FROM ubuntu:22.04` produces block_type="FROM", hierarchy="image:ubuntu:22.04"
- `test_from_with_platform`: `FROM --platform=linux/amd64 golang:1.21 AS builder` produces hierarchy="stage:builder"
- `test_from_scratch`: `FROM scratch` produces block_type="FROM", hierarchy="image:scratch"
- `test_run_instruction`: `RUN apt-get update` produces block_type="RUN", hierarchy=""
- `test_copy_instruction`: `COPY . /app` produces block_type="COPY", hierarchy=""
- `test_env_instruction`: `ENV NODE_ENV=production` produces block_type="ENV", hierarchy=""
- `test_comment_before_instruction`: `# install deps\nRUN apt-get install` produces block_type="RUN"
- `test_leading_newline`: `\nFROM golang:1.21 AS builder` handles leading whitespace
- `test_unrecognized_content`: `echo "not a dockerfile instruction"` produces block_type="", hierarchy="", language_id="dockerfile"

`TestExtractBashMetadata`:
- `test_posix_function`: `deploy_app() {` produces block_type="function", hierarchy="function:deploy_app", language_id="bash"
- `test_ksh_function`: `function deploy_app {` produces block_type="function", hierarchy="function:deploy_app"
- `test_hybrid_function`: `function deploy_app() {` produces block_type="function", hierarchy="function:deploy_app"
- `test_function_with_underscores`: `my_long_func_name() {` produces hierarchy="function:my_long_func_name"
- `test_comment_before_function`: `# Deploy the app\ndeploy_app() {` produces block_type="function"
- `test_non_function_chunk`: `echo "hello world"` produces block_type="", hierarchy="", language_id="bash"
- `test_if_block`: `if [ -f /etc/hosts ]; then` produces block_type="", hierarchy="" (not a function)
- `test_leading_newline`: `\nfunction deploy_app {` handles leading whitespace

`TestLanguageDispatchMaps`:
- `test_hcl_aliases_dispatch`: "hcl", "tf", "tfvars" all present in `_LANGUAGE_DISPATCH`
- `test_dockerfile_dispatch`: "dockerfile" present in `_LANGUAGE_DISPATCH`
- `test_bash_aliases_dispatch`: "sh", "bash", "zsh", "shell" all present in `_LANGUAGE_DISPATCH`
- `test_language_id_normalization`: "tf" maps to "hcl", "sh" maps to "bash" in `_LANGUAGE_ID_MAP`
- `test_unknown_language_not_in_dispatch`: "py", "js", "" not in `_LANGUAGE_DISPATCH`

`TestExtractDevopsMetadataDispatch`:
Test the dispatch logic WITHOUT using the `@cocoindex.op.function()` decorated version. Instead, replicate the dispatch logic inline to avoid CocoIndex runtime dependency:
- `test_python_file_returns_empty_strings`: language="py" returns all empty strings
- `test_empty_language_returns_empty_strings`: language="" returns all empty strings
- `test_hcl_via_tf_alias`: language="tf" with HCL text returns language_id="hcl" (normalized)
- `test_bash_via_sh_alias`: language="sh" with Bash text returns language_id="bash" (normalized)
- `test_devops_file_always_has_language_id`: language="hcl" with unrecognized content still returns language_id="hcl"

For the dispatch tests, manually implement the dispatch logic to test it:
```python
def _dispatch(text: str, language: str) -> DevOpsMetadata:
    """Replicate dispatch logic for testing without CocoIndex runtime."""
    extractor = _LANGUAGE_DISPATCH.get(language)
    if extractor is None:
        return _EMPTY_METADATA
    metadata = extractor(text)
    return DevOpsMetadata(
        block_type=metadata.block_type,
        hierarchy=metadata.hierarchy,
        language_id=_LANGUAGE_ID_MAP[language],
    )
```

**Part B: Update `src/cocosearch/indexer/__init__.py`**

Add metadata imports and exports. Add after the existing `extract_language` import line:

```python
from cocosearch.indexer.metadata import DevOpsMetadata, extract_devops_metadata
```

Add to `__all__` list (in alphabetical order):
- `"DevOpsMetadata"` (between `"DEFAULT_EXCLUDES"` and `"IndexingConfig"`)
- `"extract_devops_metadata"` (between `"extract_extension"` and `"extract_language"`)

Keep all existing imports and exports unchanged.
  </action>
  <verify>
Run: `cd /Users/fzhdanov/GIT/personal/coco-s && python -m pytest tests/indexer/test_metadata.py -v`
All tests pass.

Run: `cd /Users/fzhdanov/GIT/personal/coco-s && python -m pytest tests/indexer/ -v`
All indexer tests pass (test_metadata.py, test_languages.py, test_config.py -- no regressions).

Run: `cd /Users/fzhdanov/GIT/personal/coco-s && python -c "from cocosearch.indexer import DevOpsMetadata, extract_devops_metadata; print('exports OK')"`
Verify output is "exports OK".
  </verify>
  <done>
test_metadata.py has comprehensive tests covering all 3 languages with edge cases (0/1/2 HCL labels, 3 Bash function syntaxes, FROM with/without AS, comment stripping, leading whitespace, false positive prevention, dispatch maps, empty string defaults). All tests pass. __init__.py exports DevOpsMetadata and extract_devops_metadata.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/indexer/test_metadata.py -v` -- all tests pass
2. `python -m pytest tests/indexer/ -v` -- all indexer tests pass (no regressions)
3. `python -c "from cocosearch.indexer.metadata import DevOpsMetadata, extract_hcl_metadata, extract_dockerfile_metadata, extract_bash_metadata; print('imports OK')"` -- prints "imports OK"
4. `python -c "from cocosearch.indexer import DevOpsMetadata, extract_devops_metadata; print('exports OK')"` -- prints "exports OK"
5. Smoke test the 3 roadmap success criteria:
   - `extract_hcl_metadata('resource "aws_s3_bucket" "data" {')` returns block_type="resource", hierarchy="resource.aws_s3_bucket.data"
   - `extract_dockerfile_metadata('FROM golang:1.21 AS builder')` returns block_type="FROM", hierarchy="stage:builder"
   - `extract_bash_metadata('deploy_app() {')` returns block_type="function", hierarchy="function:deploy_app"
6. False positive test: `extract_hcl_metadata('# This resource was replaced\nsome_other_content')` returns block_type="" (not "resource")
</verification>

<success_criteria>
- REQ-07: HCL block type extraction works for all 12 block keywords (verified by tests)
- REQ-08: HCL hierarchy with 0, 1, or 2 labels produces correct dot-separated format (verified by tests)
- REQ-09: Dockerfile instruction type extraction works for FROM, RUN, COPY, etc. (verified by tests)
- REQ-10: Dockerfile FROM with AS produces stage:name, without AS produces image:ref (verified by tests)
- REQ-11: Bash function name extraction works for POSIX, ksh, and hybrid syntaxes (verified by tests)
- REQ-12: extract_devops_metadata decorated with @cocoindex.op.function(), returns DevOpsMetadata dataclass (verified by import)
- REQ-13: Non-DevOps files and unrecognized content return empty strings (verified by tests)
- All regex patterns compiled at module level (verified by code inspection)
- Comment stripping prevents false positives (verified by tests)
- Module exports available from cocosearch.indexer (verified by import)
</success_criteria>

<output>
After completion, create `.planning/phases/09-metadata-extraction/09-01-SUMMARY.md`
</output>
