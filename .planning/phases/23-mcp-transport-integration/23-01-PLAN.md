---
phase: 23-mcp-transport-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/mcp/server.py
  - src/cocosearch/cli.py
autonomous: true

must_haves:
  truths:
    - "User can run MCP server with stdio transport (existing behavior preserved)"
    - "User can run MCP server with SSE transport via --transport sse flag"
    - "User can run MCP server with Streamable HTTP transport via --transport http flag"
    - "User can select transport via MCP_TRANSPORT environment variable"
    - "Health endpoint returns 200 OK for network transports"
  artifacts:
    - path: "src/cocosearch/mcp/server.py"
      provides: "Multi-transport run_server() function with health endpoint"
      contains: "def run_server"
      exports: ["run_server"]
    - path: "src/cocosearch/cli.py"
      provides: "MCP subcommand with --transport and --port flags"
      contains: "--transport"
  key_links:
    - from: "src/cocosearch/cli.py"
      to: "src/cocosearch/mcp/server.py"
      via: "run_server(transport=, host=, port=)"
      pattern: "run_server\\(transport="
    - from: "src/cocosearch/mcp/server.py"
      to: "mcp.run()"
      via: "FastMCP transport parameter"
      pattern: "mcp\\.run\\(transport="
---

<objective>
Add multi-transport support to MCP server enabling runtime selection between stdio, SSE, and Streamable HTTP transports.

Purpose: Enable MCP server to work with different client types - stdio for Claude Code, SSE for Claude Desktop, HTTP for future integrations.
Output: Extended `run_server()` function with transport/host/port parameters, CLI flags `--transport` and `--port`, health endpoint for Docker healthchecks.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-mcp-transport-integration/23-CONTEXT.md
@.planning/phases/23-mcp-transport-integration/23-RESEARCH.md
@src/cocosearch/mcp/server.py
@src/cocosearch/cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend server.py with transport selection and health endpoint</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
Extend the existing `run_server()` function to accept transport parameters and add health endpoint:

1. Add health endpoint via `@mcp.custom_route`:
   ```python
   from starlette.responses import JSONResponse

   @mcp.custom_route("/health", methods=["GET"])
   async def health_check(request):
       return JSONResponse({"status": "ok"})
   ```

2. Extend `run_server()` signature:
   ```python
   def run_server(
       transport: str = "stdio",
       host: str = "0.0.0.0",
       port: int = 3000,
   ):
   ```

3. Add logging for startup (to stderr - CRITICAL for stdio):
   - Log transport type on all startups
   - For SSE: log "Connect at http://{host}:{port}/sse"
   - For HTTP: log "Connect at http://{host}:{port}/mcp"
   - For stdio with non-default port: warn "--port is ignored with stdio transport"

4. Implement transport dispatch:
   - "stdio": `mcp.run(transport="stdio")`
   - "sse": `mcp.run(transport="sse", host=host, port=port)`
   - "http": `mcp.run(transport="streamable-http", host=host, port=port)`

Note: FastMCP's internal transport value for HTTP is "streamable-http" not "http".

CRITICAL: All logging must go to stderr (already configured at top of file). Do not add any print() statements.
  </action>
  <verify>
1. `python -c "from cocosearch.mcp.server import run_server; import inspect; print(inspect.signature(run_server))"` shows `(transport: str = 'stdio', host: str = '0.0.0.0', port: int = 3000)`
2. `python -c "from cocosearch.mcp.server import health_check; print(health_check)"` confirms health endpoint exists
  </verify>
  <done>
- `run_server()` accepts transport, host, port parameters
- Health endpoint registered on FastMCP instance
- Transport dispatch logic handles stdio, sse, http
- Startup logging goes to stderr
  </done>
</task>

<task type="auto">
  <name>Task 2: Add --transport and --port CLI flags to mcp subcommand</name>
  <files>src/cocosearch/cli.py</files>
  <action>
Update the `mcp` subcommand in `cli.py` to support transport selection:

1. Update mcp subparser (around line 854):
   ```python
   mcp_parser = subparsers.add_parser(
       "mcp",
       help="Start MCP server for LLM integration",
       description="Start the Model Context Protocol server for use with Claude and other LLM clients.",
   )
   mcp_parser.add_argument(
       "--transport", "-t",
       choices=["stdio", "sse", "http"],
       default=None,
       help="Transport protocol (default: stdio). [env: MCP_TRANSPORT]",
   )
   mcp_parser.add_argument(
       "--port", "-p",
       type=int,
       default=None,
       help="Port for SSE/HTTP transports (default: 3000). [env: COCOSEARCH_MCP_PORT]",
   )
   ```

2. Update `mcp_command()` function to handle transport options:
   ```python
   def mcp_command(args: argparse.Namespace) -> int:
       """Start the MCP server."""
       from cocosearch.mcp import run_server

       # Resolve transport: CLI > env > default
       transport = args.transport or os.getenv("MCP_TRANSPORT", "stdio")

       # Validate transport
       valid_transports = ("stdio", "sse", "http")
       if transport not in valid_transports:
           print(f"Error: Invalid transport '{transport}'. Valid options: {', '.join(valid_transports)}", file=sys.stderr)
           return 1

       # Resolve port: CLI > env > default
       if args.port is not None:
           port = args.port
       else:
           port_env = os.getenv("COCOSEARCH_MCP_PORT", "3000")
           try:
               port = int(port_env)
           except ValueError:
               print(f"Error: Invalid port value in COCOSEARCH_MCP_PORT: '{port_env}'", file=sys.stderr)
               return 1

       try:
           run_server(transport=transport, host="0.0.0.0", port=port)
           return 0
       except OSError as e:
           if "Address already in use" in str(e):
               print(f"Error: Port {port} is already in use", file=sys.stderr)
               return 1
           raise
   ```

IMPORTANT: Error messages must go to stderr (`file=sys.stderr`) to avoid corrupting stdio transport output.
  </action>
  <verify>
1. `cocosearch mcp --help` shows `--transport` and `--port` options
2. `cocosearch mcp --transport sse --port 3001 &` starts server (then kill it)
3. `MCP_TRANSPORT=invalid cocosearch mcp` returns error "Invalid transport"
  </verify>
  <done>
- `--transport` flag accepts stdio, sse, http
- `--port` flag sets port for network transports
- Environment variables MCP_TRANSPORT and COCOSEARCH_MCP_PORT work
- Invalid transport values produce clear error message
- Port already in use produces clear error message
  </done>
</task>

</tasks>

<verification>
1. **Backward compatibility**: `cocosearch mcp` runs with stdio (unchanged behavior)
2. **SSE transport**: `cocosearch mcp --transport sse` starts SSE server on port 3000
3. **HTTP transport**: `cocosearch mcp --transport http --port 3001` starts HTTP server
4. **Environment variables**: `MCP_TRANSPORT=sse cocosearch mcp` uses SSE transport
5. **Health endpoint**: `curl http://localhost:3000/health` returns `{"status": "ok"}` when using network transport
6. **Error handling**: Invalid transport or port-in-use produces clear error message
</verification>

<success_criteria>
- TRNS-01: stdio transport works (backward compatible)
- TRNS-02: SSE transport available via `--transport sse`
- TRNS-03: Streamable HTTP transport available via `--transport http`
- TRNS-04: Transport selectable via `--transport` flag or `MCP_TRANSPORT` env var
- Health endpoint available at `/health` for network transports
</success_criteria>

<output>
After completion, create `.planning/phases/23-mcp-transport-integration/23-01-SUMMARY.md`
</output>
