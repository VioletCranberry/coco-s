---
phase: 23-mcp-transport-integration
plan: 02
type: execute
wave: 2
depends_on: ["23-01"]
files_modified:
  - tests/unit/mcp/test_server.py
  - tests/unit/test_cli.py
autonomous: true

must_haves:
  truths:
    - "Transport selection logic is tested"
    - "CLI flag parsing for transport/port is tested"
    - "Environment variable fallback is tested"
    - "Invalid transport error handling is tested"
  artifacts:
    - path: "tests/unit/mcp/test_server.py"
      provides: "Tests for run_server transport parameters"
      contains: "test_run_server"
    - path: "tests/unit/test_cli.py"
      provides: "Tests for mcp_command transport handling"
      contains: "TestMCPCommand"
  key_links:
    - from: "tests/unit/mcp/test_server.py"
      to: "src/cocosearch/mcp/server.py"
      via: "import and mock"
      pattern: "from cocosearch.mcp.server import"
    - from: "tests/unit/test_cli.py"
      to: "src/cocosearch/cli.py"
      via: "import and mock"
      pattern: "from cocosearch.cli import"
---

<objective>
Add unit tests for MCP transport selection in both server and CLI layers.

Purpose: Ensure transport selection logic, CLI flag parsing, and error handling work correctly.
Output: Test cases covering transport dispatch, CLI argument parsing, environment variable fallback, and error cases.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/23-mcp-transport-integration/23-01-SUMMARY.md
@tests/unit/mcp/test_server.py
@tests/unit/test_cli.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server.py transport tests</name>
  <files>tests/unit/mcp/test_server.py</files>
  <action>
Add a new test class `TestRunServer` to the existing test file with tests for:

1. **Test run_server signature**:
   - Verify function accepts transport, host, port parameters
   - Use `inspect.signature` to check defaults

2. **Test transport dispatch** (mock `mcp.run`):
   - stdio: calls `mcp.run(transport="stdio")`
   - sse: calls `mcp.run(transport="sse", host=..., port=...)`
   - http: calls `mcp.run(transport="streamable-http", host=..., port=...)`

3. **Test health endpoint exists**:
   - Verify `health_check` function is defined and async
   - Verify it returns JSONResponse with status ok

Example structure:
```python
class TestRunServer:
    """Tests for run_server transport selection."""

    def test_signature_has_transport_params(self):
        """run_server accepts transport, host, port parameters."""
        import inspect
        from cocosearch.mcp.server import run_server
        sig = inspect.signature(run_server)
        assert "transport" in sig.parameters
        assert "host" in sig.parameters
        assert "port" in sig.parameters
        assert sig.parameters["transport"].default == "stdio"
        assert sig.parameters["port"].default == 3000

    def test_stdio_transport_calls_mcp_run_stdio(self):
        """stdio transport calls mcp.run with transport='stdio'."""
        with patch("cocosearch.mcp.server.mcp") as mock_mcp:
            from cocosearch.mcp.server import run_server
            run_server(transport="stdio")
            mock_mcp.run.assert_called_once_with(transport="stdio")

    def test_sse_transport_calls_mcp_run_sse(self):
        """sse transport calls mcp.run with host and port."""
        with patch("cocosearch.mcp.server.mcp") as mock_mcp:
            from cocosearch.mcp.server import run_server
            run_server(transport="sse", host="127.0.0.1", port=8080)
            mock_mcp.run.assert_called_once_with(transport="sse", host="127.0.0.1", port=8080)

    def test_http_transport_calls_mcp_run_streamable_http(self):
        """http transport calls mcp.run with transport='streamable-http'."""
        with patch("cocosearch.mcp.server.mcp") as mock_mcp:
            from cocosearch.mcp.server import run_server
            run_server(transport="http", host="0.0.0.0", port=3000)
            mock_mcp.run.assert_called_once_with(transport="streamable-http", host="0.0.0.0", port=3000)


class TestHealthEndpoint:
    """Tests for health check endpoint."""

    def test_health_check_function_exists(self):
        """health_check endpoint is defined."""
        from cocosearch.mcp.server import health_check
        assert callable(health_check)

    @pytest.mark.asyncio
    async def test_health_check_returns_ok(self):
        """health_check returns status ok."""
        from cocosearch.mcp.server import health_check
        from unittest.mock import MagicMock
        request = MagicMock()
        response = await health_check(request)
        assert response.status_code == 200
```

Note: May need `pytest-asyncio` for async test. Check if already in dev dependencies. If not, test synchronously by checking function definition only.
  </action>
  <verify>
`pytest tests/unit/mcp/test_server.py -v` passes all tests including new TestRunServer and TestHealthEndpoint classes
  </verify>
  <done>
- TestRunServer class tests transport parameter dispatch
- TestHealthEndpoint class tests health check endpoint
- All new tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add CLI transport flag tests</name>
  <files>tests/unit/test_cli.py</files>
  <action>
Add a new test class `TestMCPCommand` to test the mcp subcommand transport handling:

1. **Test CLI flag parsing**:
   - `--transport sse` sets transport to sse
   - `--port 8080` sets port to 8080
   - `-t http -p 3001` uses short flags

2. **Test environment variable fallback** (mock os.getenv):
   - MCP_TRANSPORT env var used when no CLI flag
   - COCOSEARCH_MCP_PORT env var used when no --port flag

3. **Test CLI precedence over env**:
   - `--transport sse` overrides MCP_TRANSPORT=stdio

4. **Test invalid transport error**:
   - Invalid transport value returns exit code 1
   - Error message printed to stderr

5. **Test invalid port env var**:
   - Non-integer COCOSEARCH_MCP_PORT returns exit code 1

Example structure:
```python
class TestMCPCommand:
    """Tests for mcp_command transport handling."""

    def test_default_transport_is_stdio(self, monkeypatch):
        """Default transport is stdio when no flag or env."""
        monkeypatch.delenv("MCP_TRANSPORT", raising=False)
        with patch("cocosearch.cli.run_server") as mock_run:
            args = argparse.Namespace(transport=None, port=None)
            from cocosearch.cli import mcp_command
            mcp_command(args)
            mock_run.assert_called_once()
            call_kwargs = mock_run.call_args[1]
            assert call_kwargs["transport"] == "stdio"

    def test_transport_flag_overrides_env(self, monkeypatch):
        """CLI --transport overrides MCP_TRANSPORT env var."""
        monkeypatch.setenv("MCP_TRANSPORT", "stdio")
        with patch("cocosearch.cli.run_server") as mock_run:
            args = argparse.Namespace(transport="sse", port=None)
            from cocosearch.cli import mcp_command
            mcp_command(args)
            call_kwargs = mock_run.call_args[1]
            assert call_kwargs["transport"] == "sse"

    def test_env_transport_used_when_no_flag(self, monkeypatch):
        """MCP_TRANSPORT env var used when no --transport flag."""
        monkeypatch.setenv("MCP_TRANSPORT", "http")
        with patch("cocosearch.cli.run_server") as mock_run:
            args = argparse.Namespace(transport=None, port=None)
            from cocosearch.cli import mcp_command
            mcp_command(args)
            call_kwargs = mock_run.call_args[1]
            assert call_kwargs["transport"] == "http"

    def test_invalid_transport_returns_error(self, monkeypatch, capsys):
        """Invalid transport value returns exit code 1."""
        monkeypatch.setenv("MCP_TRANSPORT", "invalid")
        args = argparse.Namespace(transport=None, port=None)
        from cocosearch.cli import mcp_command
        result = mcp_command(args)
        assert result == 1
        captured = capsys.readouterr()
        assert "Invalid transport" in captured.err

    def test_port_flag_sets_port(self, monkeypatch):
        """--port flag sets server port."""
        monkeypatch.delenv("MCP_TRANSPORT", raising=False)
        with patch("cocosearch.cli.run_server") as mock_run:
            args = argparse.Namespace(transport="sse", port=8080)
            from cocosearch.cli import mcp_command
            mcp_command(args)
            call_kwargs = mock_run.call_args[1]
            assert call_kwargs["port"] == 8080

    def test_port_env_used_when_no_flag(self, monkeypatch):
        """COCOSEARCH_MCP_PORT env var used when no --port flag."""
        monkeypatch.delenv("MCP_TRANSPORT", raising=False)
        monkeypatch.setenv("COCOSEARCH_MCP_PORT", "9000")
        with patch("cocosearch.cli.run_server") as mock_run:
            args = argparse.Namespace(transport="sse", port=None)
            from cocosearch.cli import mcp_command
            mcp_command(args)
            call_kwargs = mock_run.call_args[1]
            assert call_kwargs["port"] == 9000

    def test_invalid_port_env_returns_error(self, monkeypatch, capsys):
        """Invalid COCOSEARCH_MCP_PORT returns exit code 1."""
        monkeypatch.delenv("MCP_TRANSPORT", raising=False)
        monkeypatch.setenv("COCOSEARCH_MCP_PORT", "not-a-number")
        args = argparse.Namespace(transport="sse", port=None)
        from cocosearch.cli import mcp_command
        result = mcp_command(args)
        assert result == 1
        captured = capsys.readouterr()
        assert "Invalid port" in captured.err
```
  </action>
  <verify>
`pytest tests/unit/test_cli.py::TestMCPCommand -v` passes all tests
  </verify>
  <done>
- TestMCPCommand class tests all transport CLI scenarios
- Environment variable fallback tested
- CLI precedence over env tested
- Error cases tested (invalid transport, invalid port)
- All new tests pass
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/unit/mcp/test_server.py -v` - all server tests pass
2. `pytest tests/unit/test_cli.py -v` - all CLI tests pass
3. `pytest tests/unit/ -v --tb=short` - full unit test suite passes
</verification>

<success_criteria>
- Transport selection logic has unit test coverage
- CLI flag parsing has unit test coverage
- Environment variable handling has unit test coverage
- Error handling has unit test coverage
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-mcp-transport-integration/23-02-SUMMARY.md`
</output>
