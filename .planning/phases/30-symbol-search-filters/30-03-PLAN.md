---
phase: 30-symbol-search-filters
plan: 03
type: execute
wave: 2
depends_on: ["30-02"]
files_modified:
  - src/cocosearch/cli.py
  - src/cocosearch/mcp/server.py
  - tests/unit/test_cli.py
autonomous: true

must_haves:
  truths:
    - "CLI supports --symbol-type flag for filtering by function/class/method/interface"
    - "CLI supports --symbol-name flag for glob pattern matching"
    - "MCP search_code accepts symbol_type and symbol_name parameters"
    - "MCP symbol_type accepts both string and array (OR filtering)"
    - "MCP response includes symbol metadata fields when available"
  artifacts:
    - path: "src/cocosearch/cli.py"
      provides: "CLI with --symbol-type and --symbol-name flags"
      contains: "--symbol-type"
    - path: "src/cocosearch/mcp/server.py"
      provides: "MCP search_code with symbol filtering parameters"
      contains: "symbol_type"
  key_links:
    - from: "src/cocosearch/cli.py"
      to: "src/cocosearch/search/query.py"
      via: "search() call with symbol_type and symbol_name"
      pattern: "search.*symbol_type"
    - from: "src/cocosearch/mcp/server.py"
      to: "src/cocosearch/search/query.py"
      via: "search() call with symbol_type and symbol_name"
      pattern: "search.*symbol_type"
---

<objective>
Add CLI flags and MCP parameters for symbol filtering

Purpose: Expose symbol filtering to users through both the command-line interface and MCP clients like Claude Desktop. Users can filter searches by --symbol-type function/class/method and --symbol-name pattern.

Output: Updated cli.py with new flags, updated server.py with new MCP parameters, unit tests for CLI argument parsing.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-symbol-search-filters/30-CONTEXT.md
@.planning/phases/30-symbol-search-filters/30-RESEARCH.md
@.planning/phases/30-symbol-search-filters/30-02-SUMMARY.md

Key prior work:
- Plan 30-02 added symbol_type and symbol_name to search() function
- CLI follows pattern: argparse with add_config_arg helper
- MCP uses FastMCP with Annotated types and Field descriptions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CLI --symbol-type and --symbol-name flags</name>
  <files>src/cocosearch/cli.py</files>
  <action>
**Add arguments to search_parser (after --hybrid argument):**

```python
search_parser.add_argument(
    "--symbol-type",
    help="Filter by symbol type. Options: function, class, method, interface. "
         "Can be specified multiple times for OR filtering (e.g., --symbol-type function --symbol-type method).",
    action="append",
    dest="symbol_type",
)
search_parser.add_argument(
    "--symbol-name",
    help="Filter by symbol name pattern (glob). "
         "Examples: 'get*', 'User*Service', '*Handler'. Case-insensitive matching.",
)
```

**Update search_command function:**

After query parsing, extract symbol filters:
```python
# Get symbol filters from args
symbol_type = args.symbol_type  # list[str] or None from action="append"
symbol_name = args.symbol_name  # str or None
```

Pass to search() call:
```python
results = search(
    query=query,
    index_name=index_name,
    limit=limit,
    min_score=min_score,
    language_filter=lang_filter,
    use_hybrid=use_hybrid,
    symbol_type=symbol_type,
    symbol_name=symbol_name,
)
```

**Error handling:**
The search() function already raises ValueError for invalid symbol types and pre-v1.7 indexes. The existing try/except block will catch these and display helpful messages.
  </action>
  <verify>
Run: cocosearch search --help
Should show --symbol-type and --symbol-name in help output.
  </verify>
  <done>
CLI accepts --symbol-type (can repeat) and --symbol-name flags.
Flags passed correctly to search() function.
Help text describes usage and examples.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add MCP symbol_type and symbol_name parameters</name>
  <files>src/cocosearch/mcp/server.py</files>
  <action>
**Update search_code function signature:**

Add two new parameters after use_hybrid_search:
```python
@mcp.tool()
def search_code(
    query: Annotated[str, Field(description="Natural language search query")],
    index_name: Annotated[str | None, Field(description="...")]] = None,
    limit: Annotated[int, Field(description="Maximum results to return")] = 10,
    language: Annotated[str | None, Field(description="...")] = None,
    use_hybrid_search: Annotated[bool | None, Field(description="...")] = None,
    # NEW: Symbol filtering parameters
    symbol_type: Annotated[
        str | list[str] | None,
        Field(
            description="Filter by symbol type. "
            "Single: 'function', 'class', 'method', 'interface'. "
            "Array: ['function', 'method'] for OR filtering."
        ),
    ] = None,
    symbol_name: Annotated[
        str | None,
        Field(
            description="Filter by symbol name pattern (glob). "
            "Examples: 'get*', 'User*Service', '*Handler'. "
            "Case-insensitive matching."
        ),
    ] = None,
) -> list[dict]:
```

**Update search() call:**
```python
results = search(
    query=query,
    index_name=index_name,
    limit=limit,
    language_filter=language,
    use_hybrid=use_hybrid_search,
    symbol_type=symbol_type,
    symbol_name=symbol_name,
)
```

**Update result dict construction:**
Always include symbol metadata in response (from SearchResult):
```python
result_dict = {
    # ... existing fields ...
    # Symbol metadata (always included, None if not available)
    "symbol_type": r.symbol_type,
    "symbol_name": r.symbol_name,
    "symbol_signature": r.symbol_signature,
}
```

**Error handling:**
When search() raises ValueError (invalid type or pre-v1.7 index), catch and return error response:
```python
except ValueError as e:
    return [{
        "error": "Symbol filter error",
        "message": str(e),
        "results": []
    }]
```
  </action>
  <verify>
Start MCP server and verify tool schema shows new parameters:
Run: python -c "from cocosearch.mcp.server import search_code; import inspect; print(inspect.signature(search_code))"
Should show symbol_type and symbol_name in signature.
  </verify>
  <done>
MCP search_code accepts symbol_type (str or list) and symbol_name (str).
Response always includes symbol_type, symbol_name, symbol_signature.
Errors return structured response with helpful message.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI argument parsing tests</name>
  <files>tests/unit/test_cli.py</files>
  <action>
**Add tests for symbol filter argument parsing:**

If tests/unit/test_cli.py doesn't exist, create it. Otherwise update existing file.

Test cases:
```python
class TestSearchArgumentParsing:
    """Tests for search command argument parsing."""

    def test_symbol_type_single(self):
        """Single --symbol-type flag parses correctly."""
        # Mock sys.argv and call main or use ArgumentParser directly
        parser = create_search_parser()  # Extract parser creation for testing
        args = parser.parse_args(["query", "--symbol-type", "function"])
        assert args.symbol_type == ["function"]

    def test_symbol_type_multiple(self):
        """Multiple --symbol-type flags create list."""
        parser = create_search_parser()
        args = parser.parse_args([
            "query",
            "--symbol-type", "function",
            "--symbol-type", "method"
        ])
        assert args.symbol_type == ["function", "method"]

    def test_symbol_name_pattern(self):
        """--symbol-name accepts glob pattern."""
        parser = create_search_parser()
        args = parser.parse_args(["query", "--symbol-name", "get*"])
        assert args.symbol_name == "get*"

    def test_symbol_filters_with_other_flags(self):
        """Symbol filters work with --lang and --hybrid."""
        parser = create_search_parser()
        args = parser.parse_args([
            "query",
            "--symbol-type", "function",
            "--symbol-name", "fetch*",
            "--lang", "python",
            "--hybrid"
        ])
        assert args.symbol_type == ["function"]
        assert args.symbol_name == "fetch*"
        assert args.lang == "python"
        assert args.hybrid is True
```

If the test file doesn't use parser extraction, test by importing search_parser from cli.py or by testing argument presence in help text.
  </action>
  <verify>
Run: pytest tests/unit/test_cli.py -v -k "symbol"
All new tests pass.
  </verify>
  <done>
CLI argument parsing tests verify --symbol-type and --symbol-name behavior.
Multiple --symbol-type flags create list for OR filtering.
Tests pass.
  </done>
</task>

</tasks>

<verification>
1. CLI help: `cocosearch search --help` shows --symbol-type and --symbol-name
2. CLI parsing: Multiple --symbol-type flags create list
3. MCP schema: search_code has symbol_type and symbol_name parameters
4. MCP types: symbol_type accepts both str and list[str]
5. Response format: MCP response includes symbol metadata fields
6. Error handling: Pre-v1.7 index errors displayed helpfully in both CLI and MCP
</verification>

<success_criteria>
- CLI accepts --symbol-type flag (can be repeated for OR filtering)
- CLI accepts --symbol-name flag with glob pattern
- MCP search_code accepts symbol_type (str or list) and symbol_name
- MCP response always includes symbol_type, symbol_name, symbol_signature
- Both interfaces pass filters to search() function correctly
- Pre-v1.7 indexes show helpful error message in both CLI and MCP
- CLI argument parsing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/30-symbol-search-filters/30-03-SUMMARY.md`
</output>
