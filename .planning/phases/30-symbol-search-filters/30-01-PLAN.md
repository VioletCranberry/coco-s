---
phase: 30-symbol-search-filters
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/indexer/symbols.py
  - tests/unit/indexer/test_symbols.py
autonomous: true

must_haves:
  truths:
    - "JavaScript functions, classes, and arrow functions are extracted as symbols"
    - "TypeScript interfaces and type aliases are extracted as symbols"
    - "Go functions, methods (with receiver), and structs/interfaces are extracted"
    - "Rust functions, methods (in impl blocks), structs, traits, and enums are extracted"
  artifacts:
    - path: "src/cocosearch/indexer/symbols.py"
      provides: "Multi-language symbol extraction with JS/TS/Go/Rust support"
      contains: "_extract_javascript_symbols"
    - path: "tests/unit/indexer/test_symbols.py"
      provides: "Unit tests for all four new languages"
      min_lines: 100
  key_links:
    - from: "src/cocosearch/indexer/symbols.py"
      to: "tree_sitter_languages"
      via: "get_language() for each supported language"
      pattern: "get_language.*javascript|typescript|go|rust"
---

<objective>
Extend symbol extraction module to support JavaScript, TypeScript, Go, and Rust

Purpose: Enable symbol-aware indexing for the most popular programming languages beyond Python, so users can filter searches by symbol type and name across their polyglot codebases.

Output: Updated symbols.py with language-specific extractors for JS/TS/Go/Rust, comprehensive unit tests validating all symbol types.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-symbol-search-filters/30-CONTEXT.md
@.planning/phases/30-symbol-search-filters/30-RESEARCH.md
@.planning/phases/29-symbol-aware-indexing/29-01-SUMMARY.md

Key prior work:
- Phase 29-01 created symbols.py with Python-only support
- tree-sitter 0.21.x and tree-sitter-languages already installed
- extract_symbol_metadata() is the CocoIndex transform entry point
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-language parser initialization</name>
  <files>src/cocosearch/indexer/symbols.py</files>
  <action>
Add language-specific parser initialization following the Python pattern:

1. Add module-level language map for supported languages:
```python
LANGUAGE_MAP = {
    "js": "javascript",
    "jsx": "javascript",
    "mjs": "javascript",
    "cjs": "javascript",
    "ts": "typescript",
    "tsx": "typescript",
    "mts": "typescript",
    "cts": "typescript",
    "go": "go",
    "rs": "rust",
    "py": "python",
    "python": "python",
}
```

2. Add generic _get_parser(language: str) function that:
   - Uses module-level cache dict _PARSERS = {}
   - Calls get_language(language) and creates Parser
   - Caches parser by tree-sitter language name (not extension)

3. Update extract_symbol_metadata to use LANGUAGE_MAP for dispatch:
   - Map extension to tree-sitter language name
   - Return NULL fields for unsupported languages
   - Call appropriate extractor based on language
  </action>
  <verify>
Run: python -c "from cocosearch.indexer.symbols import LANGUAGE_MAP; print(len(LANGUAGE_MAP))"
Should output 12 (all supported extensions).
  </verify>
  <done>
LANGUAGE_MAP contains all 12 extension mappings, _get_parser works for all supported languages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement JavaScript and TypeScript extractors</name>
  <files>src/cocosearch/indexer/symbols.py</files>
  <action>
Add JavaScript/TypeScript symbol extraction functions:

**_extract_javascript_symbols(chunk_text: str, parser) -> list[dict]:**
Extract from JavaScript:
- function_declaration -> symbol_type="function", symbol_name=name, symbol_signature="function name(params)"
- lexical_declaration with arrow_function -> symbol_type="function" (named arrow functions only: const name = () => {})
- class_declaration -> symbol_type="class"
- method_definition inside class -> symbol_type="method", symbol_name="ClassName.methodName"

Walk tree recursively, tracking current_class context for qualified method names.
Use child_by_field_name("name"), ("parameters"), ("body") to navigate nodes.

**_extract_typescript_symbols(chunk_text: str, parser) -> list[dict]:**
Reuse JavaScript extraction for functions/classes, then add:
- interface_declaration -> symbol_type="interface"
- type_alias_declaration -> symbol_type="interface" (map type to interface per CONTEXT.md decision)

Key patterns from research:
- Check node.type for each construct
- Extract text using chunk_text[node.start_byte:node.end_byte]
- Qualified names: "ClassName.methodName" format
  </action>
  <verify>
Run unit tests (will add in Task 3). Quick smoke test:
```python
python -c "
from cocosearch.indexer.symbols import extract_symbol_metadata
result = extract_symbol_metadata('function fetchUser() {}', 'js')
print(result)
"
```
Should show symbol_type='function', symbol_name='fetchUser'.
  </verify>
  <done>
JavaScript extracts functions, arrow functions, classes, and methods.
TypeScript additionally extracts interfaces and type aliases.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Go and Rust extractors with tests</name>
  <files>src/cocosearch/indexer/symbols.py, tests/unit/indexer/test_symbols.py</files>
  <action>
**Add Go extractor _extract_go_symbols(chunk_text: str, parser) -> list[dict]:**
- function_declaration -> check for receiver parameter_list before name
  - No receiver: symbol_type="function"
  - Has receiver "(s *Server)": symbol_type="method", symbol_name="Server.FuncName" (extract type from receiver)
- type_declaration with type_spec:
  - struct_type -> symbol_type="class" (map struct to class)
  - interface_type -> symbol_type="interface"

**Add Rust extractor _extract_rust_symbols(chunk_text: str, parser) -> list[dict]:**
- function_item at top level -> symbol_type="function"
- impl_item with body containing function_item -> symbol_type="method", symbol_name="TypeName.method_name"
- struct_item -> symbol_type="class"
- trait_item -> symbol_type="interface"
- enum_item -> symbol_type="class" (map enum to class)

**Add comprehensive unit tests in test_symbols.py:**
Create TestJavaScriptSymbols, TestTypeScriptSymbols, TestGoSymbols, TestRustSymbols classes.
Each class should test:
- Simple function extraction
- Class/struct extraction
- Method extraction with qualified names
- Language-specific constructs (interfaces, traits, arrow functions, receivers)
- Edge cases: empty input, parse errors, no symbols

Add at least 30 new test cases total (7-8 per language).
  </action>
  <verify>
Run: pytest tests/unit/indexer/test_symbols.py -v
All tests should pass, including existing Python tests and new language tests.
  </verify>
  <done>
Go and Rust extractors implemented. All 4 languages have comprehensive unit tests.
Total test count increased by 30+ tests. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. Run all symbol tests: `pytest tests/unit/indexer/test_symbols.py -v`
2. Verify language coverage: All 5 languages (Python, JS, TS, Go, Rust) have extractors
3. Verify extension mapping: 12 extensions map to 5 tree-sitter languages
4. Verify qualified names: Methods use "ClassName.methodName" format in all languages
5. Verify graceful degradation: Unsupported languages return NULL fields
</verification>

<success_criteria>
- extract_symbol_metadata() returns correct symbols for JS, TS, Go, Rust code
- All symbol types extracted: function, class, method, interface (where applicable)
- Methods use qualified names (ClassName.methodName) in all languages
- TypeScript interfaces and type aliases both map to "interface" symbol_type
- Go receivers extracted correctly (Server.Start from func (s *Server) Start())
- Rust impl blocks yield qualified method names
- Unit tests pass for all 5 languages (40+ tests total)
- No regressions in existing Python symbol extraction
</success_criteria>

<output>
After completion, create `.planning/phases/30-symbol-search-filters/30-01-SUMMARY.md`
</output>
