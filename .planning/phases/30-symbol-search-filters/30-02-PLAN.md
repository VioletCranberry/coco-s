---
phase: 30-symbol-search-filters
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cocosearch/search/filters.py
  - src/cocosearch/search/query.py
  - src/cocosearch/search/__init__.py
  - tests/unit/search/test_filters.py
  - tests/unit/search/test_query.py
autonomous: true

must_haves:
  truths:
    - "Symbol type filter accepts single string or list of types"
    - "Symbol name filter accepts glob patterns (*, ?)"
    - "Glob patterns converted to SQL ILIKE patterns with proper escaping"
    - "Pre-v1.7 indexes with symbol filters raise helpful ValueError"
    - "Symbol filtering combines with existing language filters via AND"
  artifacts:
    - path: "src/cocosearch/search/filters.py"
      provides: "Symbol filter SQL builder"
      exports: ["build_symbol_where_clause", "glob_to_sql_pattern"]
    - path: "src/cocosearch/search/query.py"
      provides: "Search function with symbol_type and symbol_name parameters"
      contains: "symbol_type"
    - path: "tests/unit/search/test_filters.py"
      provides: "Unit tests for symbol filter SQL building"
      min_lines: 50
  key_links:
    - from: "src/cocosearch/search/query.py"
      to: "src/cocosearch/search/filters.py"
      via: "import build_symbol_where_clause"
      pattern: "from cocosearch.search.filters import"
    - from: "src/cocosearch/search/query.py"
      to: "src/cocosearch/search/db.py"
      via: "check_symbol_columns_exist"
      pattern: "check_symbol_columns_exist"
---

<objective>
Create symbol filter SQL builder and integrate into search query module

Purpose: Enable SQL-level filtering by symbol_type and symbol_name before query execution. SQL filtering is 10-100x faster than post-processing and leverages database indexes.

Output: New filters.py module with glob-to-SQL conversion, updated query.py with symbol filter parameters, comprehensive unit tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-symbol-search-filters/30-CONTEXT.md
@.planning/phases/30-symbol-search-filters/30-RESEARCH.md
@.planning/phases/29-symbol-aware-indexing/29-03-SUMMARY.md

Key prior work:
- Phase 29-03 added check_symbol_columns_exist() in db.py
- SearchResult dataclass in query.py (needs symbol fields)
- CONTEXT.md decisions: case-insensitive, glob patterns, AND combination
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create filters.py module with glob-to-SQL conversion</name>
  <files>src/cocosearch/search/filters.py, src/cocosearch/search/__init__.py</files>
  <action>
Create new module: src/cocosearch/search/filters.py

**glob_to_sql_pattern(glob_pattern: str) -> str:**
Convert shell-style glob to SQL ILIKE pattern:
1. First escape SQL special characters: % -> \%, _ -> \_
2. Then convert glob wildcards: * -> %, ? -> _

CRITICAL: Order matters! Escape first, then convert. Otherwise "get_*" incorrectly becomes "get\_%" instead of "get\_%".

Examples:
- "get*" -> "get%"
- "User*Service" -> "User%Service"
- "*Handler" -> "%Handler"
- "get_*" -> "get\\_%" (underscore escaped, then * converted)
- "find%user" -> "find\\%user" (percent escaped)

**build_symbol_where_clause(symbol_type, symbol_name) -> tuple[str, list]:**
Parameters:
- symbol_type: str | list[str] | None
- symbol_name: str | None

Returns (where_clause, params) tuple for parameterized SQL.

Logic:
1. If symbol_type is single string: "symbol_type = %s"
2. If symbol_type is list: "symbol_type IN (%s, %s, ...)" with len(list) placeholders
3. If symbol_name provided: "symbol_name ILIKE %s" with glob_to_sql_pattern(symbol_name)
4. If both provided: combine with AND
5. Return empty string if neither provided

**VALID_SYMBOL_TYPES constant:**
Set of valid types: {"function", "class", "method", "interface"}
Validate symbol_type values, raise ValueError with helpful message if invalid.

Update __init__.py to export: build_symbol_where_clause, glob_to_sql_pattern
  </action>
  <verify>
Run: python -c "from cocosearch.search.filters import glob_to_sql_pattern; print(glob_to_sql_pattern('get_*'))"
Should output: get\_%
  </verify>
  <done>
filters.py module created with glob_to_sql_pattern and build_symbol_where_clause.
SQL escaping handles %, _, *, ? correctly in proper order.
Symbol type validation raises helpful errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add symbol fields to SearchResult and update search function</name>
  <files>src/cocosearch/search/query.py</files>
  <action>
**Update SearchResult dataclass:**
Add three new optional fields:
```python
symbol_type: str | None = None
symbol_name: str | None = None
symbol_signature: str | None = None
```

**Update search() function signature:**
Add two new parameters:
```python
def search(
    query: str,
    index_name: str,
    limit: int = 10,
    min_score: float = 0.0,
    language_filter: str | None = None,
    use_hybrid: bool | None = None,
    symbol_type: str | list[str] | None = None,  # NEW
    symbol_name: str | None = None,  # NEW
) -> list[SearchResult]:
```

**Integration logic (after language filter validation, before query execution):**

1. If symbol_type or symbol_name provided:
   - Import check_symbol_columns_exist from db.py
   - Call check_symbol_columns_exist(table_name)
   - If returns False, raise ValueError:
     "Symbol filtering requires v1.7+ index. Index '{index_name}' lacks symbol columns. Re-index with 'cocosearch index' to enable symbol filtering."

2. Import build_symbol_where_clause from filters.py

3. Build symbol WHERE clause:
   ```python
   symbol_where, symbol_params = build_symbol_where_clause(symbol_type, symbol_name)
   if symbol_where:
       where_parts.append(symbol_where)
       filter_params.extend(symbol_params)
   ```

4. Update SELECT to include symbol columns when symbol filtering is active:
   Add: "symbol_type, symbol_name, symbol_signature" to select_cols

5. Update result parsing to populate new SearchResult fields.

**Note:** For now, symbol filtering is vector-only mode. Hybrid search + symbol filters is a future enhancement (leave TODO comment).
  </action>
  <verify>
Run unit tests: pytest tests/unit/search/test_query.py -v -k "search"
All existing tests should pass without regression.
  </verify>
  <done>
SearchResult has symbol fields. search() accepts symbol_type and symbol_name.
Pre-v1.7 indexes raise helpful ValueError when symbol filters used.
Symbol filters combine with language filters using AND logic.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for symbol filter functionality</name>
  <files>tests/unit/search/test_filters.py, tests/unit/search/test_query.py</files>
  <action>
**Create new test file: tests/unit/search/test_filters.py**

Test glob_to_sql_pattern:
- test_simple_wildcard: "get*" -> "get%"
- test_prefix_wildcard: "*Handler" -> "%Handler"
- test_middle_wildcard: "User*Service" -> "User%Service"
- test_question_mark: "test?" -> "test_"
- test_escape_underscore: "get_*" -> "get\\_%" (underscore escaped before * converted)
- test_escape_percent: "find%user" -> "find\\%user"
- test_combined_escaping: "get_user*" -> "get\\_user%"
- test_no_wildcards: "exactMatch" -> "exactMatch"

Test build_symbol_where_clause:
- test_single_type: symbol_type="function" -> ("symbol_type = %s", ["function"])
- test_multiple_types: symbol_type=["function", "method"] -> ("symbol_type IN (%s, %s)", ["function", "method"])
- test_name_pattern: symbol_name="get*" -> ("symbol_name ILIKE %s", ["get%"])
- test_type_and_name: both provided -> AND combination
- test_neither: both None -> ("", [])
- test_invalid_type: symbol_type="invalid" -> raises ValueError with helpful message

**Update tests/unit/search/test_query.py:**

Test search() with symbol parameters:
- test_search_symbol_type_filter: Mock database, verify SQL includes symbol_type WHERE clause
- test_search_symbol_name_filter: Mock database, verify ILIKE in SQL
- test_search_symbol_filters_combined: Both filters, verify AND combination
- test_search_symbol_filter_prv17_error: Mock check_symbol_columns_exist to return False, verify ValueError raised with helpful message
- test_search_result_includes_symbol_fields: Verify SearchResult has symbol_type, symbol_name, symbol_signature populated

Use existing test mocking patterns from test_query.py.
  </action>
  <verify>
Run: pytest tests/unit/search/test_filters.py tests/unit/search/test_query.py -v
All tests pass. Test count increased by ~15 tests.
  </verify>
  <done>
test_filters.py has comprehensive glob and WHERE clause tests.
test_query.py has symbol parameter integration tests.
All tests pass including existing tests (no regressions).
  </done>
</task>

</tasks>

<verification>
1. Run filter tests: `pytest tests/unit/search/test_filters.py -v`
2. Run query tests: `pytest tests/unit/search/test_query.py -v`
3. Verify glob escaping: get_* produces get\\_% (underscore escaped)
4. Verify type validation: Invalid types raise helpful ValueError
5. Verify pre-v1.7 handling: Symbol filters on old indexes raise helpful error
6. No regressions in existing search functionality
</verification>

<success_criteria>
- glob_to_sql_pattern correctly escapes SQL chars then converts wildcards
- build_symbol_where_clause generates parameterized SQL for single/multiple types
- search() accepts symbol_type and symbol_name parameters
- Pre-v1.7 indexes raise ValueError: "Re-index with 'cocosearch index' to enable symbol filtering"
- Symbol filters combine with language filters using AND
- SearchResult includes symbol_type, symbol_name, symbol_signature fields
- 15+ new unit tests pass
- No regressions in existing search tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-symbol-search-filters/30-02-SUMMARY.md`
</output>
