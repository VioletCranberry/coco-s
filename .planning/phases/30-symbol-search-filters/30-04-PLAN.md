---
phase: 30-symbol-search-filters
plan: 04
type: execute
wave: 2
depends_on: ["30-02"]
files_modified:
  - src/cocosearch/search/hybrid.py
  - tests/unit/search/test_hybrid.py
autonomous: true

must_haves:
  truths:
    - "Definition chunks receive 2x score boost after RRF fusion"
    - "Definitions identified by keyword prefix check (def, class, function, fn, etc.)"
    - "Boost applies to HybridSearchResult.combined_score, then re-sorted"
    - "Non-definition chunks unchanged in ranking"
    - "Boost only applied when symbol columns exist (v1.7+ index)"
  artifacts:
    - path: "src/cocosearch/search/hybrid.py"
      provides: "Definition boost after RRF fusion"
      contains: "apply_definition_boost"
    - path: "tests/unit/search/test_hybrid.py"
      provides: "Unit tests for definition boost"
      min_lines: 20
  key_links:
    - from: "src/cocosearch/search/hybrid.py"
      to: "src/cocosearch/search/db.py"
      via: "check_symbol_columns_exist"
      pattern: "check_symbol_columns_exist"
---

<objective>
Add definition score boost to hybrid search after RRF fusion

Purpose: Function and class definitions should rank higher than references in search results. This helps users find where code is defined, not just where it's used. A 2x boost is applied after RRF fusion to preserve the rank-based algorithm semantics.

Output: Updated hybrid.py with apply_definition_boost function, integrated into hybrid_search, comprehensive unit tests.
</objective>

<execution_context>
@/Users/fedorzhdanov/.claude/get-shit-done/workflows/execute-plan.md
@/Users/fedorzhdanov/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-symbol-search-filters/30-CONTEXT.md
@.planning/phases/30-symbol-search-filters/30-RESEARCH.md

Key prior work:
- hybrid.py has rrf_fusion() returning HybridSearchResult
- hybrid_search() orchestrates vector + keyword search
- CONTEXT.md decision: 2x boost for definitions, applied after RRF fusion
- RESEARCH.md: Use simple keyword prefix heuristic, not full tree-sitter parse
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement definition detection heuristic</name>
  <files>src/cocosearch/search/hybrid.py</files>
  <action>
**Add _is_definition_chunk(content: str) -> bool function:**

Check if chunk content starts with a definition keyword. This is a heuristic - fast and good enough for boosting purposes.

```python
def _is_definition_chunk(content: str) -> bool:
    """Check if chunk content starts with a definition keyword.

    Heuristic: definition chunks start with keywords like:
    - def, class, async def (Python)
    - function, const name = (JavaScript/TypeScript)
    - func, type (Go)
    - fn, struct, trait, enum, impl (Rust)

    Args:
        content: Chunk text content.

    Returns:
        True if chunk appears to be a definition.
    """
    stripped = content.lstrip()
    definition_keywords = [
        # Python
        "def ", "class ", "async def ",
        # JavaScript/TypeScript
        "function ", "const ", "let ", "var ", "class ", "interface ", "type ",
        # Go
        "func ", "type ",
        # Rust
        "fn ", "struct ", "trait ", "enum ", "impl ",
    ]
    return any(stripped.startswith(kw) for kw in definition_keywords)
```

Note: This is intentionally simple. Some false positives (const for non-functions) are acceptable - the boost helps more than it hurts. Users searching for definitions will get them ranked higher.
  </action>
  <verify>
Run: python -c "
from cocosearch.search.hybrid import _is_definition_chunk
print(_is_definition_chunk('def foo():'))  # True
print(_is_definition_chunk('func main() {'))  # True
print(_is_definition_chunk('x = foo()'))  # False
"
  </verify>
  <done>
_is_definition_chunk function detects definition keywords for Python, JS/TS, Go, Rust.
Returns True for definition-starting content, False otherwise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement apply_definition_boost function</name>
  <files>src/cocosearch/search/hybrid.py</files>
  <action>
**Add apply_definition_boost function:**

```python
def apply_definition_boost(
    results: list[HybridSearchResult],
    index_name: str,
    boost_multiplier: float = 2.0,
) -> list[HybridSearchResult]:
    """Apply score boost to definition symbols.

    Definitions are identified by checking if chunk content starts with
    definition keywords (def/class/func/fn/etc.). Boost is applied after
    RRF fusion to preserve rank-based algorithm semantics.

    Args:
        results: Fused hybrid search results.
        index_name: Name of the index (for symbol column check).
        boost_multiplier: Multiplier for definition scores (default 2.0).

    Returns:
        Results with boosted scores, re-sorted by new scores.
    """
    if not results:
        return results

    # Check if symbol columns exist (v1.7+ index)
    # If not, skip boost - can't reliably identify definitions
    from cocosearch.search.db import check_symbol_columns_exist, get_table_name
    table_name = get_table_name(index_name)
    if not check_symbol_columns_exist(table_name):
        logger.debug("Skipping definition boost - symbol columns not available")
        return results

    # Import chunk content reader
    from cocosearch.search import read_chunk_content

    boosted_results = []
    for result in results:
        # Read chunk content to check if definition
        try:
            content = read_chunk_content(
                result.filename,
                result.start_byte,
                result.end_byte
            )
            is_definition = _is_definition_chunk(content)
        except Exception:
            # If we can't read content, don't boost
            is_definition = False

        if is_definition:
            # Create new result with boosted score
            boosted_results.append(
                HybridSearchResult(
                    filename=result.filename,
                    start_byte=result.start_byte,
                    end_byte=result.end_byte,
                    combined_score=result.combined_score * boost_multiplier,
                    match_type=result.match_type,
                    vector_score=result.vector_score,
                    keyword_score=result.keyword_score,
                    block_type=result.block_type,
                    hierarchy=result.hierarchy,
                    language_id=result.language_id,
                )
            )
        else:
            boosted_results.append(result)

    # Re-sort by boosted scores (descending)
    # Maintain keyword tiebreaker from rrf_fusion
    boosted_results.sort(
        key=lambda r: (r.combined_score, 1 if r.keyword_score is not None else 0),
        reverse=True,
    )

    return boosted_results
```
  </action>
  <verify>
Run: python -c "from cocosearch.search.hybrid import apply_definition_boost; print('OK')"
Should output: OK
  </verify>
  <done>
apply_definition_boost function boosts definition scores by 2x and re-sorts.
Skips boost gracefully if symbol columns don't exist.
Uses keyword prefix heuristic for definition detection.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate boost into hybrid_search and add tests</name>
  <files>src/cocosearch/search/hybrid.py, tests/unit/search/test_hybrid.py</files>
  <action>
**Update hybrid_search function:**

After RRF fusion and before returning results, apply definition boost:
```python
def hybrid_search(
    query: str,
    index_name: str,
    limit: int = 10,
) -> list[HybridSearchResult]:
    # ... existing code ...

    # Fuse results using RRF
    fused = rrf_fusion(vector_results, keyword_results)

    # Apply definition boost (after RRF, before limit)
    boosted = apply_definition_boost(fused, index_name)

    return boosted[:limit]
```

Also apply boost in the vector-only fallback path (when no keyword results):
```python
if not keyword_results:
    vector_only_results = [
        HybridSearchResult(...)
        for r in vector_results[:limit]
    ]
    # Apply boost even in vector-only mode
    return apply_definition_boost(vector_only_results, index_name)[:limit]
```

**Add unit tests in test_hybrid.py:**

```python
class TestDefinitionBoost:
    """Tests for definition boost functionality."""

    def test_is_definition_chunk_python_def(self):
        """Python def detected as definition."""
        assert _is_definition_chunk("def foo():\n    pass") is True

    def test_is_definition_chunk_python_class(self):
        """Python class detected as definition."""
        assert _is_definition_chunk("class Foo:\n    pass") is True

    def test_is_definition_chunk_js_function(self):
        """JavaScript function detected as definition."""
        assert _is_definition_chunk("function fetchUser() {}") is True

    def test_is_definition_chunk_go_func(self):
        """Go func detected as definition."""
        assert _is_definition_chunk("func main() {\n}") is True

    def test_is_definition_chunk_rust_fn(self):
        """Rust fn detected as definition."""
        assert _is_definition_chunk("fn process() -> Result<()>") is True

    def test_is_definition_chunk_not_definition(self):
        """Non-definition content not detected."""
        assert _is_definition_chunk("x = foo()") is False
        assert _is_definition_chunk("// comment") is False
        assert _is_definition_chunk("return result") is False

    def test_apply_definition_boost_multiplies_score(self, mocker):
        """Definition chunks get 2x score boost."""
        # Mock check_symbol_columns_exist to return True
        mocker.patch(
            "cocosearch.search.hybrid.check_symbol_columns_exist",
            return_value=True
        )
        # Mock read_chunk_content to return definition content
        mocker.patch(
            "cocosearch.search.hybrid.read_chunk_content",
            return_value="def foo():\n    pass"
        )

        results = [
            HybridSearchResult(
                filename="test.py",
                start_byte=0,
                end_byte=100,
                combined_score=0.5,
                match_type="both",
                vector_score=0.6,
                keyword_score=0.4,
            )
        ]

        boosted = apply_definition_boost(results, "test_index")
        assert boosted[0].combined_score == 1.0  # 0.5 * 2.0

    def test_apply_definition_boost_skips_prv17(self, mocker):
        """Boost skipped when symbol columns don't exist."""
        mocker.patch(
            "cocosearch.search.hybrid.check_symbol_columns_exist",
            return_value=False
        )

        results = [
            HybridSearchResult(
                filename="test.py",
                start_byte=0,
                end_byte=100,
                combined_score=0.5,
                match_type="both",
                vector_score=0.6,
                keyword_score=0.4,
            )
        ]

        boosted = apply_definition_boost(results, "test_index")
        assert boosted[0].combined_score == 0.5  # Unchanged
```
  </action>
  <verify>
Run: pytest tests/unit/search/test_hybrid.py -v -k "definition"
All definition boost tests pass.
  </verify>
  <done>
hybrid_search applies definition boost after RRF fusion.
Both hybrid and vector-only paths apply boost.
Unit tests verify 2x multiplier and graceful skip for pre-v1.7.
  </done>
</task>

</tasks>

<verification>
1. Run hybrid tests: `pytest tests/unit/search/test_hybrid.py -v`
2. Verify definition detection: Keywords for Python, JS, TS, Go, Rust recognized
3. Verify boost math: 2x multiplier applied correctly
4. Verify re-sorting: Boosted results sorted by new scores
5. Verify graceful skip: Pre-v1.7 indexes don't crash, just skip boost
6. No regressions in existing hybrid search tests
</verification>

<success_criteria>
- _is_definition_chunk detects def/class/function/func/fn keywords
- apply_definition_boost multiplies definition scores by 2.0
- Results re-sorted after boost application
- Pre-v1.7 indexes skip boost gracefully (no error)
- hybrid_search integrates boost after RRF fusion
- Both hybrid and vector-only paths apply boost
- 8+ new unit tests pass
- No regressions in existing hybrid search tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-symbol-search-filters/30-04-SUMMARY.md`
</output>
